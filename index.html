<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Siege AI Edition - Refined Wind Blades & Gameplay</title>
    <style>
        body {
            min-height: 100vh;
            margin: 0;
            padding: 10px 0;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ecf0f1;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #main-content-wrapper {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
        }

        .ui-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 5px;
            padding: 10px 0;
            font-size: 14px;
        }
         .ui-container::-webkit-scrollbar {
            width: 8px;
        }
        .ui-container::-webkit-scrollbar-track {
            background: rgba(44, 62, 80, 0.3);
            border-radius: 4px;
        }
        .ui-container::-webkit-scrollbar-thumb {
            background: #7f8c8d;
            border-radius: 44px;
        }
        .ui-container::-webkit-scrollbar-thumb:hover {
            background: #95a5a6;
        }

        #gameCanvasContainer {
            position: relative;
            padding-top: 75%;
            border: 1px solid #7f8c8d;
            box-sizing: border-box;
            background-color: #333745;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .stats-left, .stats-middle, .stats-right {
            background-color: rgba(44, 62, 80, 0.8);
            border-radius: 5px;
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
        }
        .stats-left { min-width: 320px; flex-shrink: 0; }
        .stats-middle { flex-grow: 1; text-align: left; margin: 0 10px;}
        .stats-right { text-align: right; min-width: 160px; flex-shrink: 0; }

        .collapsible-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(127, 140, 141, 0.3);
        }
        .collapsible-panel-header.collapsed-state {
            border-bottom: none;
        }
        .collapsible-panel-title {
            font-weight: bold;
            color: #ecf0f1;
        }
        .collapsible-panel-toggle-btn {
            background: none;
            border: 1px solid #7f8c8d;
            color: #ecf0f1;
            padding: 1px 7px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            line-height: 1.2;
            margin-left: 10px;
        }
        .collapsible-panel-toggle-btn:hover {
            background-color: rgba(127, 140, 141, 0.2);
        }
        .collapsible-panel-content {
            padding: 10px;
        }
        .collapsible-panel-content.collapsed {
            display: none;
            padding: 0;
        }

        .stats-left p, .stats-middle p, .stats-right p { margin: 4px 0; }
        .collapsible-panel-content > p:first-child,
        .collapsible-panel-content > .progress-bar-container:first-child,
        .collapsible-panel-content > .stats-title:first-child {
             margin-top: 0;
        }
         .collapsible-panel-content > *:first-child {
            margin-top: 2px;
        }
        .collapsible-panel-content > *:last-child {
            margin-bottom: 0;
        }


        .progress-bar-container { width: 150px; height: 10px; background-color: #7f8c8d; border-radius: 5px; overflow: hidden; margin-top: 3px; }
        .progress-bar { height: 100%; background-color: #2ecc71; transition: width 0.2s ease-out; }
        .xp-bar { background-color: #3498db; }
        .stats-middle .stats-title { text-align: center; font-weight: bold; margin-bottom: 8px !important; }
        .stats-middle .zombie-type-label { font-weight: bold; color: #e67e22; display: block; margin-top: 6px; margin-bottom: 2px;}
        .modal { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: rgba(52, 73, 94, 0.97); padding: 20px; border-radius: 10px; border: 2px solid #95a5a6; z-index: 1000; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); max-height: 80vh; overflow-y: auto; }
        .modal h3 { margin-top: 0; color: #e67e22; }
        .modal button.skill-option-btn, .modal button.close-btn { background-color: #2980b9; color: white; border: none; padding: 10px 15px; margin: 10px 5px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.3s; }
        .modal button.skill-option-btn:hover { background-color: #3498db; }
        .modal button.close-btn { background-color: #c0392b; margin-top: 20px; }
        .modal button.close-btn:hover { background-color: #e74c3c; }
        #skillModal { width: 500px; }
        #skillTimer { margin-top: 15px; font-size: 12px; color: #bdc3c7; }
        #skillBookModal { width: 600px; text-align: left; }
        #skillBookModal .skill-entry { background-color: rgba(44, 62, 80, 0.7); padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #7f8c8d; }
        #skillBookModal .skill-entry.learned { border-left-color: #2ecc71; }
        #skillBookModal .skill-entry h4 { margin: 0 0 5px 0; color: #ecf0f1; }
        #skillBookModal .skill-entry p { margin: 0; font-size: 0.9em; color: #bdc3c7; }
        #skillBookModal .skill-level { font-weight: bold; color: #f1c40f; }
        #gameOverScreen, #startGamePrompt { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: rgba(44, 62, 80, 0.95); padding: 30px; border-radius: 10px; text-align: center; z-index: 1001; border: 1px solid #7f8c8d; }
        #gameOverScreen h2, #startGamePrompt h2 { margin-top: 0; color: white; }
        #gameOverScreen button, #startGamePrompt button { background-color: #2ecc71; color: white; border: none; padding: 10px 20px; margin: 10px 5px; border-radius: 5px; cursor: pointer; font-size: 16px; }
        #startGamePrompt button.new-game-btn { background-color: #3498db; }

        .game-buttons {
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .game-buttons button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 3px 0;
            border-radius: 3px;
            cursor: pointer;
            min-width: 100px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            font-size: 13px;
        }

        #bossRewardModal { width: 400px; }
        #bossRewardModal ul { list-style-type: none; padding: 0; }
        #bossRewardModal li { background-color: rgba(44, 62, 80, 0.6); padding: 8px; margin: 5px 0; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="startGamePrompt">
        <h2>游戏存档</h2>
        <p>发现之前的游戏存档。</p>
        <button onclick="continueGame()">继续游戏</button>
        <button class="new-game-btn" onclick="startNewGame()">开始新游戏</button>
    </div>

    <div id="main-content-wrapper">
        <div class="ui-container">
            <div class="stats-left">
                <div class="collapsible-panel-header" data-panel-id="statsLeftPanel">
                    <span class="collapsible-panel-title">玩家状态</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p>生命值: <span id="playerHp">100</span> / <span id="playerMaxHp">100</span></p>
                    <div class="progress-bar-container"><div class="progress-bar" id="playerHpBar" style="width: 100%;"></div></div>
                    <p>经验值: <span id="playerXp">0</span> / <span id="xpToLevelUp">100</span> (等级 <span id="playerLevel">1</span>)</p>
                    <div class="progress-bar-container"><div class="progress-bar xp-bar" id="playerXpBar" style="width: 0%;"></div></div>
                    <p>主子弹: 伤害 <span id="bulletDamageDisplay">10.0</span> | 弹道 <span id="projectileCountDisplay">1</span> | 每道 <span id="bulletsPerShotDisplay">1</span> | 穿透 <span id="bulletPierceCountDisplay">0</span></p>
                    <p>史莱姆: 数量 <span id="slimeCountDisplay">0</span> | 伤害 <span id="slimeDamageDisplay">25.0</span> | 速度 <span id="slimeSpeedDisplay">0.60</span></p>
                    <p>能量波: <span id="hasEnergyWaveDisplay">否</span> | 伤害 <span id="energyWaveDamageDisplay">15</span> | CD <span id="energyWaveCooldownDisplay">30</span>s</p>
                    <p id="windBladeStatsRow">风刃: 数量 <span id="windBladeCountDisplay">0</span> | 伤害 <span id="windBladeDamageDisplay">10</span> | 减速 <span id="windBladeSlowPercentDisplay">20%</span> | 持续 <span id="windBladeSlowDurationDisplay">1.0s</span> | CD <span id="windBladeCooldownDisplay">15</span>s</p>
                    <p>每5秒生命回复: <span id="hpRegenPer5SecDisplay">1</span></p>
                    <p>经验获取倍率: <span id="xpGainMultiplierDisplay">100%</span></p>
                </div>
            </div>
            <div class="stats-middle">
                <div class="collapsible-panel-header" data-panel-id="statsMiddlePanel">
                    <span class="collapsible-panel-title">敌人属性</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p class="stats-title" id="middleStatsTitle">当前波数僵尸属性</p>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">普通型:</span>
                        <p>生命 <span id="zombieNormalHp">N/A</span> | 伤害 <span id="zombieNormalDamage">N/A</span> | 速度 <span id="zombieNormalSpeed">N/A</span></p>
                    </div>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">快速型:</span>
                        <p>生命 <span id="zombieFastHp">N/A</span> | 伤害 <span id="zombieFastDamage">N/A</span> | 速度 <span id="zombieFastSpeed">N/A</span></p>
                    </div>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">坦克型:</span>
                        <p>生命 <span id="zombieTankHp">N/A</span> | 伤害 <span id="zombieTankDamage">N/A</span> | 速度 <span id="zombieTankSpeed">N/A</span></p>
                    </div>
                    <div id="bossStatsDisplay" style="display:none;">
                         <p>生命: <span id="bossHpDisplay">N/A</span> / <span id="bossMaxHpDisplay">N/A</span></p>
                         <p>速度: <span id="bossSpeedDisplay">N/A</span> (<span id="bossPhaseDisplay">阶段 1</span>)</p>
                    </div>
                    <p class="stats-note" id="zombieStatsNote"></p>
                </div>
            </div>
            <div class="stats-right">
                <div class="collapsible-panel-header" data-panel-id="statsRightPanel">
                    <span class="collapsible-panel-title">游戏信息与控制</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p>波数: <span id="waveCount">1</span></p>
                    <p>分数: <span id="scoreCount">0</span></p>
                    <div class="game-buttons">
                        <button onclick="toggleSkillBook()">查看技能</button>
                        <button onclick="saveGame()">保存游戏</button>
                        <button id="toggleBgBtn" onclick="toggleAutoChangeBackground()">更换背景: 开</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameCanvasContainer">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>


    <div id="skillModal" class="modal"><h3>选择一个技能！</h3><div id="skillOptions"></div><p id="skillTimer">剩余时间: 6s</p></div>
    <div id="skillBookModal" class="modal"><h3>技能书</h3><div id="skillBookContent"></div><button class="close-btn" onclick="toggleSkillBook()">关闭</button></div>
    <div id="gameOverScreen"><h2>游戏结束!</h2><p>最终波数: <span id="finalWave"></span></p><p>最终分数: <span id="finalScore"></span></p><button onclick="startNewGame(true)">重新开始</button></div>
    <div id="bossRewardModal" class="modal">
        <h3>Boss Defeated! Skills Acquired:</h3>
        <div id="bossRewardSkillList"></div>
        <p id="bossRewardTimer">Closing in: 6s</p>
        <button class="close-btn" onclick="closeBossRewardModal()">关闭</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');

        const BASE_CANVAS_WIDTH = 800;
        const BASE_CANVAS_HEIGHT = 600;

        const playerHpDisplay = document.getElementById('playerHp'); const playerMaxHpDisplay = document.getElementById('playerMaxHp'); const playerHpBar = document.getElementById('playerHpBar');
        const playerXpDisplay = document.getElementById('playerXp'); const xpToLevelUpDisplay = document.getElementById('xpToLevelUp'); const playerLevelDisplay = document.getElementById('playerLevel'); const playerXpBar = document.getElementById('playerXpBar');
        const bulletDamageDisplay = document.getElementById('bulletDamageDisplay'); const projectileCountDisplay = document.getElementById('projectileCountDisplay'); const bulletsPerShotDisplay = document.getElementById('bulletsPerShotDisplay'); const bulletPierceCountDisplay = document.getElementById('bulletPierceCountDisplay');
        const waveCountDisplay = document.getElementById('waveCount'); const scoreCountDisplay = document.getElementById('scoreCount');
        const skillModal = document.getElementById('skillModal'); const skillOptionsContainer = document.getElementById('skillOptions'); const skillTimerDisplay = document.getElementById('skillTimer');
        const skillBookModal = document.getElementById('skillBookModal'); const skillBookContent = document.getElementById('skillBookContent');
        const gameOverScreen = document.getElementById('gameOverScreen'); const finalWaveDisplay = document.getElementById('finalWave'); const finalScoreDisplay = document.getElementById('finalScore');
        const startGamePrompt = document.getElementById('startGamePrompt');
        const hpRegenPer5SecDisplay = document.getElementById('hpRegenPer5SecDisplay'); const xpGainMultiplierDisplay = document.getElementById('xpGainMultiplierDisplay');
        const slimeCountDisplay = document.getElementById('slimeCountDisplay'); const slimeDamageDisplay = document.getElementById('slimeDamageDisplay'); const slimeSpeedDisplay = document.getElementById('slimeSpeedDisplay');
        const hasEnergyWaveDisplay = document.getElementById('hasEnergyWaveDisplay'); const energyWaveDamageDisplay = document.getElementById('energyWaveDamageDisplay'); const energyWaveCooldownDisplay = document.getElementById('energyWaveCooldownDisplay');
        const windBladeStatsRow = document.getElementById('windBladeStatsRow');
        const windBladeDamageDisplay = document.getElementById('windBladeDamageDisplay'); const windBladeCooldownDisplay = document.getElementById('windBladeCooldownDisplay'); const windBladeCountDisplay = document.getElementById('windBladeCountDisplay');
        const windBladeSlowPercentDisplay = document.getElementById('windBladeSlowPercentDisplay'); const windBladeSlowDurationDisplay = document.getElementById('windBladeSlowDurationDisplay');


        const zombieNormalHpDisplay = document.getElementById('zombieNormalHp'); const zombieNormalDamageDisplay = document.getElementById('zombieNormalDamage'); const zombieNormalSpeedDisplay = document.getElementById('zombieNormalSpeed');
        const zombieFastHpDisplay = document.getElementById('zombieFastHp'); const zombieFastDamageDisplay = document.getElementById('zombieFastDamage'); const zombieFastSpeedDisplay = document.getElementById('zombieFastSpeed');
        const zombieTankHpDisplay = document.getElementById('zombieTankHp'); const zombieTankDamageDisplay = document.getElementById('zombieTankDamage'); const zombieTankSpeedDisplay = document.getElementById('zombieTankSpeed');

        const middleStatsTitle = document.getElementById('middleStatsTitle');
        const zombieTypeStatContainers = document.querySelectorAll('.zombie-type-stats-container');
        const bossStatsDisplay = document.getElementById('bossStatsDisplay');
        const bossHpDisplay = document.getElementById('bossHpDisplay');
        const bossMaxHpDisplay = document.getElementById('bossMaxHpDisplay');
        const bossSpeedDisplay = document.getElementById('bossSpeedDisplay');
        const bossPhaseDisplay = document.getElementById('bossPhaseDisplay');
        const zombieStatsNote = document.getElementById('zombieStatsNote');

        const bossRewardModal = document.getElementById('bossRewardModal');
        const bossRewardSkillList = document.getElementById('bossRewardSkillList');
        const bossRewardTimerDisplay = document.getElementById('bossRewardTimer');
        const toggleBgBtn = document.getElementById('toggleBgBtn');
        let toggleSoundBtn;


        let player, zombies, bullets, energyWaves, windBlades, currentBoss, bossSummons;
        let wave, score, gameRunning, skillSelectionActive, skillBookOpen, bossRewardModalActive;
        let skillSelectionTimeoutId, skillSelectionCountdownIntervalId; let animationFrameId = null;
        let bossRewardTimeoutId, bossRewardCountdownIntervalId;

        let autoChangeBackground = true;
        let nextBackgroundImage = null;
        let oldBackgroundImage = null;
        let crossfadeProgress = 1;
        const crossfadeDuration = 1000;
        let lastLoopTimestamp = 0;

        let isFetchingNextBackground = false;
        let currentBackgroundSeed = Math.floor(Math.random() * 1000000);
        const REMOTE_BACKGROUND_BASE_URL = 'https://image.pollinations.ai/prompt/Gritty%202D%20isometric%20game%20art%2C%20top-down%20view%20of%20a%20desolate%2C%20ruined%20city%20street%2C%20abandoned%20cars%20scattered%20among%20rubble%20and%20cracked%20asphalt%2C%20muted%20color%20palette%2C%20strategic%20game%20map%20feel?width=1216&height=832&seed={SEED}&model=flux&enhance=true&nologo=true&safe=false';


        const INITIAL_BULLET_DAMAGE = 10; const PLAYER_SHOOT_COOLDOWN = 800; const INTER_BULLET_DELAY = 80;
        let lastShotTime = 0; let timeOfLastBurstBullet = 0;
        const XP_PER_LEVEL = [0, 70, 150, 300, 450, 625, 825, 1050, 1300, 1575, 1875, 2200, 2550, 2925, 3325, 3750];

        const ZOMBIE_TYPES = {
            normal: { hp: 22, speed: 0.28, damage: 6, xp: 10, color: '#27ae60', size: 15 },
            fast:   { hp: 12, speed: 0.5, damage: 2, xp: 15, color: '#f1c40f', size: 12 },
            tank:   { hp: 50, speed: 0.15, damage: 10, xp: 30, color: '#c0392b', size: 20 }
        };

        const BOSS_STATS = {
            id: "circling_menace",
            baseHp: 1000,
            damage: 999999,
            baseXp: 1000,
            color: '#9b59b6',
            size: 65,
            baseSpeed: 0.4,
            pointsPerCircle: 32,
            currentPathTargetIndex: 0,
            summonCooldowns: { normal: false, fast: false, tank: false },
            hpThresholds: { normal: 0.9, fast: 0.8, tank: 0.7 },
            finalSpeedMultiplier: 1.5,
            pathState: 'outer_circle',
            finalApproachBaseSpeed: 0.20,
        };


        let nextUniqueId = 0; const MAX_SLIME_SPEED_MULTIPLIER = 5.0;
        const ALL_SKILLS = [
            { id: 'hp_boost', name: '生命强化', description: '最大生命值增加50, 并回复新最大生命值的50%。', category: 'player',
                apply: (p) => {
                    const oldMaxHp = p.maxHp;
                    p.maxHp += 50;
                    p.hp = Math.min(p.hp + (p.maxHp * 0.50), p.maxHp);
                }
            },
            { id: 'life_heal_over_time', name: '生命治愈', description: '每5秒回复1点生命', category: 'player', apply: (p) => { p.hpRegenPer5Sec += 1; } },
            { id: 'xp_gain_boost', name: '经验加速', description: '获取经验值增加20% (最高200%)', category: 'player',
                apply: (p) => { p.xpGainMultiplier = Math.min(p.xpGainMultiplier + 0.20, 2.0); }
            },
            { id: 'damage_boost_flat', name: '主子弹强化 (固定)', description: '主子弹固定伤害增加10点', category: 'bullet', apply: (p) => { p.bulletFlatDamageBonus += 10; } },
            { id: 'damage_boost_percent', name: '主子弹强化 (百分比)', description: '当前主子弹伤害增加60%', category: 'bullet', apply: (p) => { p.bulletDamageMultiplier += 0.6; } },
            { id: 'projectile_increase', name: '弹道增加', description: '增加一个弹道，但主子弹伤害减少15%', category: 'bullet', maxStacks: 20, apply: (p) => { p.projectileCount++; p.bulletDamageMultiplier -= 0.15; } },
            { id: 'multishot', name: '子弹连发', description: '每个弹道，每次射击增加一个主子弹，但主子弹伤害减少15%', category: 'bullet', maxStacks: 20, apply: (p) => { p.bulletsPerShot++; p.bulletDamageMultiplier -= 0.15; } },
            { id: 'bullet_pierce', name: '子弹穿透', description: '主子弹可以穿透一个敌人', category: 'bullet', maxStacks: 20, apply: (p) => { p.bulletPierceCount += 1; } },
            { id: 'summon_slime', name: '召唤史莱姆', description: '召唤一个史莱姆，触碰到的僵尸将每秒受到25伤害', category: 'slime', maxStacks: 1,
                apply: function(p) {
                    let newSlimeX, newSlimeY; let attempts = 0; const MAX_ATTEMPTS = 20; const slimeSize = 10; let positionFound = false;
                    while (attempts < MAX_ATTEMPTS && !positionFound) {
                        const offsetX = Math.random() * 40 - 20; const offsetY = Math.random() * 40 - 20;
                        newSlimeX = p.x + offsetX; newSlimeY = p.y + offsetY; positionFound = true;
                        for (const existingSlime of p.slimes) {
                            if (Math.hypot(newSlimeX - existingSlime.x, newSlimeY - existingSlime.y) < (slimeSize + existingSlime.size) / 2 + 3) {
                                positionFound = false; break;
                            }
                        } attempts++;
                    }
                    if (!positionFound) { newSlimeX = p.x; newSlimeY = p.y; }
                    p.slimes.push({ id: nextUniqueId++, x: newSlimeX, y: newSlimeY, size: slimeSize, color: 'rgba(52, 152, 219, 0.7)', baseSpeed: 0.6, targetEnemyId: null, targetIsBoss: false, lastDamageApplicationTimes: {} });
                }
            },
            { id: 'slime_surge', name: '史莱姆涌动', description: '新召唤一个史莱姆，但是史莱姆伤害减少20%', category: 'slime', maxStacks: 20, prerequisite: 'summon_slime',
                apply: function(p) {
                    let newSlimeX, newSlimeY; let attempts = 0; const MAX_ATTEMPTS = 20; const slimeSize = 10; let positionFound = false;
                     while (attempts < MAX_ATTEMPTS && !positionFound) {
                        const offsetX = Math.random() * 40 - 20; const offsetY = Math.random() * 40 - 20;
                        newSlimeX = p.x + offsetX; newSlimeY = p.y + offsetY; positionFound = true;
                        for (const existingSlime of p.slimes) {
                             if (Math.hypot(newSlimeX - existingSlime.x, newSlimeY - existingSlime.y) < (slimeSize + existingSlime.size) / 2 + 3) {
                                positionFound = false; break;
                            }
                        } attempts++;
                    }
                    if (!positionFound) { newSlimeX = p.x; newSlimeY = p.y; }
                    p.slimes.push({ id: nextUniqueId++, x: newSlimeX, y: newSlimeY, size: slimeSize, color: 'rgba(52, 152, 219, 0.7)', baseSpeed: 0.6, targetEnemyId: null, targetIsBoss: false, lastDamageApplicationTimes: {} });
                    p.slimeDamagePercentMultiplier -= 0.20;
                }
            },
            { id: 'slime_devour', name: '史莱姆吞噬', description: '史莱姆伤害增加60%', category: 'slime', prerequisite: 'summon_slime', apply: (p) => { p.slimeDamagePercentMultiplier += 0.60; } },
            { id: 'slime_accelerate', name: '史莱姆加速', description: '史莱姆移动速度增加25% (最高500%基础速度)', category: 'slime', prerequisite: 'summon_slime',
                apply: (p) => { p.slimeSpeedMultiplier = Math.min(p.slimeSpeedMultiplier + 0.25, MAX_SLIME_SPEED_MULTIPLIER); }
            },
            { id: 'energy_wave_aoe', name: '能量波动', description: '每30秒发射环形能量波，造成15伤害', category: 'energy_wave', maxStacks: 1, apply: (p) => { p.hasEnergyWave = true; } },
            { id: 'energy_wave_damage_up', name: '能量增强', description: '增加100%能量波的伤害', category: 'energy_wave', prerequisite: 'energy_wave_aoe', apply: (p) => { p.energyWaveDamageMultiplier += 1.00; } },
            { id: 'energy_wave_cooldown_down', name: '能量聚集', description: '减少能量波动的冷却1秒 (最低10秒)', category: 'energy_wave', prerequisite: 'energy_wave_aoe',
                apply: (p) => { p.energyWaveCooldown = Math.max(10000, p.energyWaveCooldown - 1000); }
            },
            { id: 'summon_wind_blade', name: '风刃召唤', description: '发射月牙形风刃，伤害10，减速20%持续1秒，冷却15秒。升级增加数量。', category: 'wind_blade', maxStacks: 8,
                apply: (p) => {
                    if (!p.hasWindBlade) {
                        p.hasWindBlade = true;
                        p.windBladeCount = 1;
                    } else {
                        p.windBladeCount = Math.min(p.windBladeCount + 1, 8);
                    }
                }
            },
            { id: 'wind_blade_damage_up', name: '风刃强化', description: '风刃伤害提高60%。', category: 'wind_blade', prerequisite: 'summon_wind_blade',
                apply: (p) => { p.windBladeDamageMultiplier += 0.60; }
            },
            { id: 'wind_blade_force_up', name: '风力加强', description: '风刃减速比例提高2%，持续时间增加0.2秒。', category: 'wind_blade', prerequisite: 'summon_wind_blade', maxStacks: 20,
                apply: (p) => { p.windBladeSlowBonus += 0.02; p.windBladeSlowDurationBonus += 0.2; }
            },
            { id: 'wind_blade_size_up', name: '狂风', description: '增加风刃大小20%。', category: 'wind_blade', prerequisite: 'summon_wind_blade', maxStacks: 5,
                apply: (p) => { p.windBladeSizeMultiplier += 0.20; }
            }
        ];
        const SKILL_CATEGORY_ORDER = ['player', 'bullet', 'slime', 'energy_wave', 'wind_blade'];

        let soundEnabled = true;

        const soundEffectPaths = {
            shoot: 'sounds/shoot.mp3',
            zombieDie: 'sounds/zombie_die.mp3',
            playerHurt: 'sounds/player_hurt.mp3',
            levelUp: 'sounds/level_up.mp3',
            gameOver: 'sounds/game_over.mp3',
            waveStart: 'sounds/wave_start.mp3',
            bossSpawn: 'sounds/boss_summon.mp3',
            bossDie: 'sounds/boss_die.mp3',
            skillSelect: 'sounds/skill_select.mp3',
            energyWaveFire: 'sounds/energy_wave_fire.mp3',
            slimeAttack: 'sounds/slime_attack.mp3',
            buttonClick: 'sounds/button_click.mp3',
            skillAcquired: 'sounds/skill_acquired.mp3',
            bossSummon: 'sounds/boss_summon.mp3'
        };

        const soundEffectVolumes = {
            shoot: 0.15,
            zombieDie: 0.3,
            playerHurt: 0.3,
            levelUp: 0.5,
            gameOver: 0.6,
            waveStart: 0.3,
            bossSpawn: 0.4,
            bossDie: 0.4,
            skillSelect: 0.3,
            energyWaveFire: 0.3,
            slimeAttack: 0.5,
            buttonClick: 0.4,
            skillAcquired: 0.5,
            bossSummon: 0.35
        };

        const soundEffectPoolSizes = {
            shoot: 10,
            zombieDie: 15,
            playerHurt: 3,
            levelUp: 1,
            gameOver: 1,
            waveStart: 1,
            bossDie: 1,
            skillSelect: 1,
            energyWaveFire: 1,
            slimeAttack: 5,
            buttonClick: 3,
            skillAcquired: 1,
            bossSummon: 5
        };

        let activeBossSpawnSound = null;
        let audioPools = {};
        let nextAudioIndex = {};

        function initializeSoundPlayers() {
            for (const key in soundEffectPaths) {
                if (key === 'bossSpawn') continue;

                const poolSize = soundEffectPoolSizes[key] || 1;
                audioPools[key] = [];
                nextAudioIndex[key] = 0;

                for (let i = 0; i < poolSize; i++) {
                    const audio = new Audio(soundEffectPaths[key]);
                    audio.volume = soundEffectVolumes[key] !== undefined ? soundEffectVolumes[key] : 0.3;
                    audio.preload = 'auto';
                    audioPools[key].push(audio);
                }
            }
        }

       function playSound(soundKey) {
            if (!soundEnabled || !soundEffectPaths[soundKey]) return;

            const volume = soundEffectVolumes[soundKey] !== undefined ? soundEffectVolumes[soundKey] : 0.3;

            if (soundKey === 'bossSpawn') {
                const audio = new Audio(soundEffectPaths[soundKey]);
                audio.volume = volume;

                if (activeBossSpawnSound && activeBossSpawnSound !== audio) {
                    fadeOutAndStop(activeBossSpawnSound, 500);
                }
                activeBossSpawnSound = audio;

                audio.play().catch(e => { console.error("Error playing boss spawn sound:", e); });

                const fadeStartDelay = 9000;
                const fadeDuration = 3000;

                setTimeout(() => {
                    if (activeBossSpawnSound === audio && audio.volume > 0 && !audio.paused) {
                        fadeOutAndStop(audio, fadeDuration);
                    }
                }, fadeStartDelay);

                audio.onended = () => {
                    if (activeBossSpawnSound === audio) {
                        activeBossSpawnSound = null;
                        audio.src = '';
                        audio.load();
                    }
                };

            } else {
                const pool = audioPools[soundKey];
                if (!pool || pool.length === 0) {
                    console.warn(`Audio pool for ${soundKey} is empty or not initialized.`);
                    const tempAudio = new Audio(soundEffectPaths[soundKey]);
                    tempAudio.volume = volume;
                    tempAudio.play().catch(e => {});
                    return;
                }

                let audioToPlay = null;

                for(let i = 0; i < pool.length; i++) {
                    const candidateAudio = pool[(nextAudioIndex[soundKey] + i) % pool.length];
                    if (candidateAudio.paused || candidateAudio.ended) {
                        audioToPlay = candidateAudio;
                        nextAudioIndex[soundKey] = (nextAudioIndex[soundKey] + i + 1) % pool.length;
                        break;
                    }
                }

                if (!audioToPlay) {
                    audioToPlay = pool[nextAudioIndex[soundKey]];
                    nextAudioIndex[soundKey] = (nextAudioIndex[soundKey] + 1) % pool.length;
                    
                    audioToPlay.pause();
                    audioToPlay.currentTime = 0;
                }

                audioToPlay.volume = volume;
                audioToPlay.play().catch(e => {
                    if (e.name === 'NotAllowedError') {
                        console.warn("Autoplay was prevented for sound:", soundKey, e);
                    } else {
                        console.error("Error playing sound:", soundKey, e);
                    }
                });
            }
        }


        function fadeOutAndStop(audioInstance, duration = 2000) {
            if (!audioInstance) return;
             if (audioInstance.volume === 0 && activeBossSpawnSound === audioInstance) {
                activeBossSpawnSound = null;
                if(!audioInstance.paused) {
                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                }
                return;
            }
            if (audioInstance.volume === 0) return;


            let currentVolume = audioInstance.volume;
            const steps = 50;
            const stepTime = duration / steps;
            const volumeDecrement = currentVolume / steps;

            let fadeInterval = setInterval(() => {
                currentVolume -= volumeDecrement;
                if (currentVolume <= 0) {
                    audioInstance.volume = 0;
                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                    clearInterval(fadeInterval);
                    if (activeBossSpawnSound === audioInstance) {
                        activeBossSpawnSound = null;
                    }
                } else {
                    audioInstance.volume = currentVolume;
                }
            }, stepTime);
        }


        function toggleSound() {
            soundEnabled = !soundEnabled;
            toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;
            localStorage.setItem('zombieSiegeSoundEnabled', soundEnabled);
            if (!soundEnabled && activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
            }
        }


        let localBackgroundImage = new Image();
        let localBackgroundImageProcessed = false;
        localBackgroundImage.onload = function() {
            localBackgroundImageProcessed = true;
            if (!backgroundImageProcessed) {
                backgroundImage = localBackgroundImage;
                backgroundImageProcessed = true;
            }
            startGameManager();
        };
        localBackgroundImage.onerror = function() {
            localBackgroundImageProcessed = true;
            if (!backgroundImageProcessed) {
                backgroundImageProcessed = true;
            }
            startGameManager();
        };
        localBackgroundImage.src = './background.jpg';

        let backgroundImage = localBackgroundImage;
        let backgroundImageProcessed = false;


        function fetchNextBackgroundImage() {
            if (!autoChangeBackground || isFetchingNextBackground) {
                return;
            }
            isFetchingNextBackground = true;
            currentBackgroundSeed = Math.floor(Math.random() * 1000000);
            const url = REMOTE_BACKGROUND_BASE_URL.replace('{SEED}', currentBackgroundSeed);

            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = function() {
                nextBackgroundImage = img;
                isFetchingNextBackground = false;
            };
            img.onerror = function() {
                console.warn("Failed to load remote background. Retrying in 3s.");
                isFetchingNextBackground = false;
                setTimeout(fetchNextBackgroundImage, 3000);
            };
            img.src = url;
        }

        function toggleAutoChangeBackground() {
            playSound('buttonClick');
            autoChangeBackground = !autoChangeBackground;
            toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            localStorage.setItem('zombieSiegeAutoBg', JSON.stringify(autoChangeBackground));
            if (autoChangeBackground && !nextBackgroundImage && !isFetchingNextBackground) {
                fetchNextBackgroundImage();
            }
        }

        function startGameManager() {
            if (gameRunning && (localBackgroundImageProcessed || backgroundImageProcessed) && animationFrameId === null) {
                if(!backgroundImageProcessed && localBackgroundImageProcessed) {
                    backgroundImage = localBackgroundImage;
                    backgroundImageProcessed = true;
                }
                lastLoopTimestamp = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function initializeNewGameVariables() {
            const now = performance.now();
            player = {
                x: BASE_CANVAS_WIDTH / 2, y: BASE_CANVAS_HEIGHT / 2, size: 20, color: '#3498db',
                hp: 100, maxHp: 100, xp: 0, level: 1,
                initialBulletDamage: INITIAL_BULLET_DAMAGE, bulletFlatDamageBonus: 0, bulletDamageMultiplier: 0,
                projectileCount: 1, bulletsPerShot: 1, shootCooldown: PLAYER_SHOOT_COOLDOWN,
                xpGainMultiplier: 1, learnedSkills: {}, currentBulletInBurst: 0,
                hpRegenPer5Sec: 1, lastHpRegenTime: now,
                bulletPierceCount: 0,
                slimes: [], slimeBaseDamage: 25, slimeDamagePercentMultiplier: 0, slimeSpeedMultiplier: 1,
                hasEnergyWave: false, energyWaveBaseDamage: 15,
                energyWaveDamageMultiplier: 0, energyWaveCooldown: 30000, lastEnergyWaveTime: now - 30000 + Math.min(5000, 30000),
                hasWindBlade: false, windBladeBaseDamage: 10, windBladeDamageMultiplier: 0, windBladeCount: 0,
                windBladeCooldown: 15000, lastWindBladeTime: now - 15000 + Math.min(5000, 15000),
                windBladeBaseSlow: 0.20, windBladeSlowBonus: 0, windBladeBaseSlowDuration: 1, windBladeSlowDurationBonus: 0,
                windBladeSizeMultiplier: 1.0,
            };
            zombies = []; bullets = []; energyWaves = []; windBlades = []; currentBoss = null; bossSummons = [];
            wave = 0; score = 0; nextUniqueId = 0;
            lastShotTime = now - player.shootCooldown - 200;
            timeOfLastBurstBullet = now - INTER_BULLET_DELAY - 200;
            player.currentBulletInBurst = 0;
            oldBackgroundImage = null;
            crossfadeProgress = 1;
            if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) {
                fetchNextBackgroundImage();
            }
        }

        function initGame(isNewGame = false) {
            gameOverScreen.style.display = 'none'; skillModal.style.display = 'none'; skillBookModal.style.display = 'none'; bossRewardModal.style.display = 'none';

            const savedAutoBg = localStorage.getItem('zombieSiegeAutoBg');
            if (savedAutoBg !== null) {
                autoChangeBackground = JSON.parse(savedAutoBg);
            }
            if (toggleBgBtn) toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;



            if (!toggleSoundBtn) {
                 toggleSoundBtn = document.createElement('button');

                 const gameButtonsDiv = document.querySelector('.stats-right .game-buttons');
                 if (gameButtonsDiv) { gameButtonsDiv.appendChild(toggleSoundBtn); }
            }
            toggleSoundBtn.onclick = ()=>{playSound('buttonClick'); toggleSound();};
            const savedSoundEnabled = localStorage.getItem('zombieSiegeSoundEnabled');
            if (savedSoundEnabled !== null) {
                soundEnabled = JSON.parse(savedSoundEnabled);
            }
            toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;


            if (!isNewGame && localStorage.getItem('zombieSiegeSaveData')) { startGamePrompt.style.display = 'block'; gameRunning = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } return; }
            startGamePrompt.style.display = 'none';
            initializeNewGameVariables();
            gameRunning = true; skillSelectionActive = false; skillBookOpen = false; bossRewardModalActive = false;
            advanceWave(); updateUI(); startGameManager();
        }

        function startNewGame(fromGameOver = false) {
            playSound('buttonClick');
            if (fromGameOver) gameOverScreen.style.display = 'none'; startGamePrompt.style.display = 'none';
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            initGame(true);
        }

        function continueGame() {
            if (activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 200);
                activeBossSpawnSound = null;
            }
            playSound('buttonClick');

            startGamePrompt.style.display = 'none';
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

            const loaded = loadGame();
            if (loaded) {
                if (player.hp <= 0) { updateUI(); gameOver(); return; }
                gameRunning = true; skillSelectionActive = false; skillBookOpen = false; bossRewardModalActive = false;
                if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) { fetchNextBackgroundImage(); }
                updateUI(); startGameManager();
            }
            else { alert("存档加载失败，开始新游戏。"); startNewGame(); }
        }

        function saveGame() {
            playSound('buttonClick');
            if (!player) { alert("游戏尚未开始，无法保存。"); return; }
            player.xpGainMultiplier = Math.min(player.xpGainMultiplier, 2.0);

            const saveData = { player: JSON.parse(JSON.stringify(player)), zombies: JSON.parse(JSON.stringify(zombies)), bullets: bullets.map(bullet => ({ ...bullet, hitTargets: bullet.hitTargets ? Array.from(bullet.hitTargets) : [] })), energyWaves: energyWaves.map(ew => ({ ...ew, hitZombies: Array.from(ew.hitZombies) })), windBlades: windBlades.map(wb => ({...wb, hitTargets: Array.from(wb.hitTargets)})), currentBoss: currentBoss ? JSON.parse(JSON.stringify(currentBoss)) : null, bossSummons: bossSummons ? JSON.parse(JSON.stringify(bossSummons)) : [], wave, score, nextUniqueId, lastShotTime, timeOfLastBurstBullet };
            try {
                localStorage.setItem('zombieSiegeSaveData', JSON.stringify(saveData));
                localStorage.setItem('zombieSiegeAutoBg', JSON.stringify(autoChangeBackground));
                localStorage.setItem('zombieSiegeSoundEnabled', soundEnabled);
                alert('游戏已保存!');
            } catch (e) { console.error("Save game error:", e); alert('保存游戏失败，可能是存储已满。'); }
        }

        function loadGame() {
            const saveDataString = localStorage.getItem('zombieSiegeSaveData');
            const autoBgString = localStorage.getItem('zombieSiegeAutoBg');
            if (autoBgString !== null) {
                autoChangeBackground = JSON.parse(autoBgString);
                if(toggleBgBtn) toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            }
            const soundEnabledString = localStorage.getItem('zombieSiegeSoundEnabled');
             if (soundEnabledString !== null) {
                soundEnabled = JSON.parse(soundEnabledString);
                if (toggleSoundBtn) toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;
            }


            if (!saveDataString) return false;
            try {
                const saveData = JSON.parse(saveDataString);
                player = saveData.player;
                
                zombies = (saveData.zombies || []).map(z => {
                    const baseStats = ZOMBIE_TYPES[z.type] || ZOMBIE_TYPES.normal;
                    const waveStats = getZombieStatsForWave(baseStats, z.type, saveData.wave);
                    return {
                        ...z,
                        originalSpeed: z.originalSpeed !== undefined ? z.originalSpeed : (waveStats.speed || baseStats.speed),
                        slowUntil: z.slowUntil || 0,
                        maxHp: z.maxHp || (waveStats.hp || baseStats.hp),
                        speed: z.speed !== undefined ? z.speed : (waveStats.speed || baseStats.speed)
                    };
                });
                bossSummons = (saveData.bossSummons || []).map(s => {
                    const baseStats = ZOMBIE_TYPES[s.type] || ZOMBIE_TYPES.normal;
                    const waveStats = getZombieStatsForWave(baseStats, s.type, saveData.wave);
                    return {
                        ...s,
                        originalSpeed: s.originalSpeed !== undefined ? s.originalSpeed : (waveStats.speed || baseStats.speed),
                        slowUntil: s.slowUntil || 0,
                        maxHp: s.maxHp || (waveStats.hp || baseStats.hp),
                        speed: s.speed !== undefined ? s.speed : (waveStats.speed || baseStats.speed)
                    };
                });

                bullets = saveData.bullets.map(bulletData => ({ ...bulletData, hitTargets: new Set(bulletData.hitTargets || []) }));
                energyWaves = saveData.energyWaves.map(ew => ({ ...ew, hitZombies: new Set(ew.hitZombies) }));
                windBlades = saveData.windBlades ? saveData.windBlades.map(wb => ({...wb, hitTargets: new Set(wb.hitTargets || [])})) : [];
                currentBoss = saveData.currentBoss || null;
                wave = saveData.wave;
                score = saveData.score;
                nextUniqueId = saveData.nextUniqueId;

                const currentLoadTime = performance.now();


                player.initialBulletDamage = typeof player.initialBulletDamage === 'number' ? player.initialBulletDamage : INITIAL_BULLET_DAMAGE;
                player.bulletFlatDamageBonus = typeof player.bulletFlatDamageBonus === 'number' ? player.bulletFlatDamageBonus : 0;
                player.bulletDamageMultiplier = typeof player.bulletDamageMultiplier === 'number' ? player.bulletDamageMultiplier : 0;
                player.projectileCount = typeof player.projectileCount === 'number' ? player.projectileCount : 1;
                player.bulletsPerShot = typeof player.bulletsPerShot === 'number' ? player.bulletsPerShot : 1;
                player.shootCooldown = typeof player.shootCooldown === 'number' ? player.shootCooldown : PLAYER_SHOOT_COOLDOWN;
                player.xpGainMultiplier = Math.min(player.xpGainMultiplier || 1, 2.0);
                player.learnedSkills = player.learnedSkills || {};
                player.currentBulletInBurst = 0;
                player.hpRegenPer5Sec = typeof player.hpRegenPer5Sec === 'number' ? player.hpRegenPer5Sec : 1;
                player.bulletPierceCount = typeof player.bulletPierceCount === 'number' ? player.bulletPierceCount : 0;
                player.slimes = player.slimes || [];
                player.slimes.forEach(s => s.baseSpeed = s.baseSpeed || 0.6);
                player.slimes.forEach(s => s.color = s.color || 'rgba(52, 152, 219, 0.7)');
                player.slimeBaseDamage = typeof player.slimeBaseDamage === 'number' ? player.slimeBaseDamage : 25;
                player.slimeDamagePercentMultiplier = typeof player.slimeDamagePercentMultiplier === 'number' ? player.slimeDamagePercentMultiplier : 0;
                player.slimeSpeedMultiplier = typeof player.slimeSpeedMultiplier === 'number' ? player.slimeSpeedMultiplier : 1;
                player.hasEnergyWave = typeof player.hasEnergyWave === 'boolean' ? player.hasEnergyWave : false;
                player.energyWaveBaseDamage = typeof player.energyWaveBaseDamage === 'number' ? player.energyWaveBaseDamage : 15;
                player.energyWaveDamageMultiplier = typeof player.energyWaveDamageMultiplier === 'number' ? player.energyWaveDamageMultiplier : 0;
                player.energyWaveCooldown = typeof player.energyWaveCooldown === 'number' ? player.energyWaveCooldown : 30000;


                player.hasWindBlade = player.hasWindBlade || false;
                player.windBladeBaseDamage = player.windBladeBaseDamage || 10;
                player.windBladeDamageMultiplier = player.windBladeDamageMultiplier || 0;
                player.windBladeCount = player.windBladeCount || 0;
                player.windBladeCooldown = player.windBladeCooldown || 15000;
                player.windBladeBaseSlow = player.windBladeBaseSlow || 0.20;
                player.windBladeSlowBonus = player.windBladeSlowBonus || 0;
                player.windBladeBaseSlowDuration = player.windBladeBaseSlowDuration || 1;
                player.windBladeSlowDurationBonus = player.windBladeSlowDurationBonus || 0;
                player.windBladeSizeMultiplier = player.windBladeSizeMultiplier || 1.0;


                player.lastHpRegenTime = currentLoadTime;
                const energyWaveReadyDelay = Math.min(5000, player.energyWaveCooldown);
                player.lastEnergyWaveTime = currentLoadTime - player.energyWaveCooldown + energyWaveReadyDelay;
                const windBladeReadyDelay = Math.min(5000, player.windBladeCooldown);
                player.lastWindBladeTime = currentLoadTime - player.windBladeCooldown + windBladeReadyDelay;


                lastShotTime = currentLoadTime - (player.shootCooldown || PLAYER_SHOOT_COOLDOWN) - 200;
                timeOfLastBurstBullet = currentLoadTime - INTER_BULLET_DELAY - 200;
                player.currentBulletInBurst = 0;


                if (currentBoss) {
                    currentBoss.originalSpeed = currentBoss.originalSpeed || BOSS_STATS.baseSpeed * (1.0 + Math.max(0, Math.floor(wave / 10) - 1) * 0.05);
                    currentBoss.speed = currentBoss.speed || currentBoss.originalSpeed;
                    currentBoss.pathSegments = currentBoss.pathSegments || [];
                    currentBoss.currentPathTargetIndex = currentBoss.currentPathTargetIndex || 0;
                    currentBoss.summonCooldowns = currentBoss.summonCooldowns || { normal: false, fast: false, tank: false };
                    currentBoss.hpThresholds = currentBoss.hpThresholds || BOSS_STATS.hpThresholds;
                    currentBoss.finalSpeedMultiplier = currentBoss.finalSpeedMultiplier || BOSS_STATS.finalSpeedMultiplier;
                    currentBoss.pathState = currentBoss.pathState || 'outer_circle';
                    currentBoss.finalApproachBaseSpeed = currentBoss.finalApproachBaseSpeed || BOSS_STATS.finalApproachBaseSpeed * (1.0 + Math.max(0, Math.floor(wave / 10) - 1) * 0.05);
                    currentBoss.phaseEntered = currentBoss.phaseEntered || { normal: false, fast: false, tank: false };
                    currentBoss.finalSpeedBoostApplied = currentBoss.finalSpeedBoostApplied || false;
                }
                player.slimes.forEach(s => {
                    s.targetEnemyId = s.targetEnemyId || null;
                    s.targetIsBoss = typeof s.targetIsBoss === 'boolean' ? s.targetIsBoss : false;
                    s.lastDamageApplicationTimes = s.lastDamageApplicationTimes || {};
                });

                return true;
            } catch (e) { console.error("Load game error:", e); localStorage.removeItem('zombieSiegeSaveData'); return false; }
        }

        function calculateBulletDamage() { let baseDmg = player.initialBulletDamage + player.bulletFlatDamageBonus; let finalDmg = baseDmg * (1 + player.bulletDamageMultiplier); return parseFloat(Math.max(finalDmg, player.initialBulletDamage * 0.2).toFixed(1));}
        function calculateSlimeDamage() { return parseFloat(Math.max(player.slimeBaseDamage * (1 + player.slimeDamagePercentMultiplier), player.slimeBaseDamage * 0.2).toFixed(1)); }
        function calculateEnergyWaveDamage() { return parseFloat(Math.max(player.energyWaveBaseDamage * (1 + player.energyWaveDamageMultiplier), player.energyWaveBaseDamage * 0.2).toFixed(1));}
        function calculateCurrentSlimeSpeed(slime) { return parseFloat((slime.baseSpeed * player.slimeSpeedMultiplier).toFixed(2)); }
        function calculateWindBladeDamage() { return parseFloat(Math.max(player.windBladeBaseDamage * (1 + player.windBladeDamageMultiplier), player.windBladeBaseDamage * 0.2).toFixed(1)); }
        function calculateWindBladeSlowPercent() { return player.windBladeBaseSlow + player.windBladeSlowBonus; }
        function calculateWindBladeSlowDuration() { return player.windBladeBaseSlowDuration + player.windBladeSlowDurationBonus; }


        function getZombieStatsForWave(baseStats, zombieTypeKey, currentWave) {
            let hp, damage, speed;

            if (currentWave <= 0) return { hp: baseStats.hp, damage: baseStats.damage, speed: baseStats.speed };

            let hpBonus = 0;
            let dmgBonus = 0;
            let cumulativeSpeedFactor = 0;

            // Tier 1: 波次 1-50 (玩家前期) 增长率适中
            const wavesInTier1 = Math.min(currentWave, 50);
            hpBonus += Math.floor(wavesInTier1 / 3) * (baseStats.hp * 0.1);
            dmgBonus += Math.floor(wavesInTier1 / 5) * 1.0;
            cumulativeSpeedFactor += wavesInTier1 * 0.003;


            // Tier 2: 波次 51-200 (游戏中期) 增长率提升
            if (currentWave > 50) {
                const wavesInTier2 = Math.min(currentWave, 200) - 50;
                // 普通僵尸: 逐渐增加坦度和伤害
                hpBonus += Math.floor(wavesInTier2 / 2) * (baseStats.hp * 0.2);
                dmgBonus += Math.floor(wavesInTier2 / 3) * 2.0;

                // 快速型僵尸: 速度和伤害开始明显提升
                if (zombieTypeKey === 'fast') {
                    cumulativeSpeedFactor += wavesInTier2 * 0.01; // 快速型加速
                    dmgBonus += Math.floor(wavesInTier2 / 2) * 3.0; // 快速型伤害加速
                } else if (zombieTypeKey === 'tank') {
                    // 坦克型僵尸: 生命值显著提升
                    hpBonus += Math.floor(wavesInTier2 / 1) * (baseStats.hp * 0.5); // 坦克型生命值大幅加速
                }
                cumulativeSpeedFactor += wavesInTier2 * 0.005; // 整体速度增长
            }

            // Tier 3: 波次 201-400 (游戏中后期) 增长率进一步加大
            if (currentWave > 200) {
                const wavesInTier3 = Math.min(currentWave, 400) - 200;
                hpBonus += Math.floor(wavesInTier3 / 1) * (baseStats.hp * 0.35); // 快速增长
                dmgBonus += Math.floor(wavesInTier3 / 1) * 3.0; // 快速增长

                if (zombieTypeKey === 'fast') {
                    cumulativeSpeedFactor += wavesInTier3 * 0.015; // 快速型加速
                    dmgBonus += Math.floor(wavesInTier3 / 1) * 5.0; // 快速型伤害加速
                } else if (zombieTypeKey === 'tank') {
                    hpBonus += Math.floor(wavesInTier3 / 1) * (baseStats.hp * 1.0); // 坦克型生命值进一步大幅加速
                }
                cumulativeSpeedFactor += wavesInTier3 * 0.008; // 整体速度增长
            }


            // Tier 4: 波次 401+ (游戏后期) 增长率最快，针对性加强
            if (currentWave > 400) {
                const post400Waves = currentWave - 400;
                let post400HpFactor_type, post400DmgFactor_type, post400SpeedFactor_type;

                if (zombieTypeKey === 'normal') {
                    post400HpFactor_type = 1.0;
                    post400DmgFactor_type = 5.0;
                    post400SpeedFactor_type = 0.003;
                } else if (zombieTypeKey === 'fast') {
                    // 快速型僵尸：生命增长更快，伤害非常高，速度非常快
                    post400HpFactor_type = 0.6;
                    post400DmgFactor_type = 8.0; // 快速型僵尸伤害爆炸增长
                    post400SpeedFactor_type = 0.03; // 快速型僵尸速度爆炸增长
                } else if (zombieTypeKey === 'tank') {
                    // 坦克型僵尸：生命值爆炸增长，伤害也很高
                    post400HpFactor_type = 4.0; // 坦克型僵尸生命爆炸增长
                    post400DmgFactor_type = 7.0;
                    post400SpeedFactor_type = 0.008;
                } else {
                    post400HpFactor_type = 1.0;
                    post400DmgFactor_type = 5.0;
                    post400SpeedFactor_type = 0.01;
                }

                hpBonus += Math.floor(post400Waves / 1) * (baseStats.hp * post400HpFactor_type); // 每波都涨生命
                dmgBonus += Math.floor(post400Waves / 1) * post400DmgFactor_type; // 每波都涨伤害
                cumulativeSpeedFactor += post400Waves * post400SpeedFactor_type; // 每波都涨速度
            }

            hp = baseStats.hp + hpBonus;
            damage = baseStats.damage + dmgBonus;
            speed = baseStats.speed * (1 + cumulativeSpeedFactor);
            
            // 确保僵尸的速度不会过快导致难以捕捉或逻辑崩溃
            const MAX_POSSIBLE_SPEED = 15.0; // 略微放宽最大速度限制，让快速型有更显著效果
            speed = Math.min(speed, MAX_POSSIBLE_SPEED);

            return { hp, damage, speed };
        }

        function updateUI() {
            if (!player) return;
            playerHpDisplay.textContent = Math.max(0, Math.ceil(player.hp)); playerMaxHpDisplay.textContent = player.maxHp; playerHpBar.style.width = `${(Math.max(0, player.hp) / player.maxHp) * 100}%`;
            const xpNeeded = (player.level < XP_PER_LEVEL.length) ? XP_PER_LEVEL[player.level] : XP_PER_LEVEL[XP_PER_LEVEL.length - 1] + (player.level - (XP_PER_LEVEL.length - 1)) * 500;
            playerXpDisplay.textContent = player.xp; xpToLevelUpDisplay.textContent = xpNeeded; playerLevelDisplay.textContent = player.level; playerXpBar.style.width = xpNeeded === Infinity ? '100%' : `${(player.xp / xpNeeded) * 100}%`;
            bulletDamageDisplay.textContent = calculateBulletDamage(); projectileCountDisplay.textContent = player.projectileCount; bulletsPerShotDisplay.textContent = player.bulletsPerShot; bulletPierceCountDisplay.textContent = player.bulletPierceCount;
            hpRegenPer5SecDisplay.textContent = player.hpRegenPer5Sec; xpGainMultiplierDisplay.textContent = `${(player.xpGainMultiplier * 100).toFixed(0)}%`;

            const exampleSlimeForSpeedDisplay = player.slimes.length > 0 ? player.slimes[0] : { baseSpeed: 0.6 };
            slimeSpeedDisplay.textContent = calculateCurrentSlimeSpeed(exampleSlimeForSpeedDisplay);
            slimeCountDisplay.textContent = player.slimes.length; slimeDamageDisplay.textContent = calculateSlimeDamage();

            hasEnergyWaveDisplay.textContent = player.hasEnergyWave ? '是' : '否'; energyWaveDamageDisplay.textContent = calculateEnergyWaveDamage(); energyWaveCooldownDisplay.textContent = (player.energyWaveCooldown / 1000).toFixed(1);


            windBladeCountDisplay.textContent = player.windBladeCount;
            windBladeDamageDisplay.textContent = calculateWindBladeDamage();
            windBladeCooldownDisplay.textContent = (player.windBladeCooldown / 1000).toFixed(1);
            if (windBladeSlowPercentDisplay) windBladeSlowPercentDisplay.textContent = `${(calculateWindBladeSlowPercent() * 100).toFixed(0)}%`;
            if (windBladeSlowDurationDisplay) windBladeSlowDurationDisplay.textContent = `${calculateWindBladeSlowDuration().toFixed(1)}s`;


            waveCountDisplay.textContent = wave; scoreCountDisplay.textContent = score;

            if (currentBoss && currentBoss.hp > 0) {
                middleStatsTitle.textContent = "当前BOSS属性"; middleStatsTitle.style.display = 'block';
                zombieTypeStatContainers.forEach(c => c.style.display = 'none'); zombieStatsNote.style.display = 'none'; bossStatsDisplay.style.display = 'block';
                bossHpDisplay.textContent = Math.ceil(currentBoss.hp); bossMaxHpDisplay.textContent = Math.ceil(currentBoss.maxHp);
                bossSpeedDisplay.textContent = currentBoss.speed.toFixed(2);

                let phaseText = "阶段未知";
                const hpPercent = currentBoss.hp / currentBoss.maxHp;
                if (hpPercent > BOSS_STATS.hpThresholds.normal) phaseText = `阶段 1 (100%-${(BOSS_STATS.hpThresholds.normal * 100).toFixed(0)}%)`;
                else if (hpPercent > BOSS_STATS.hpThresholds.fast) phaseText = `阶段 2 (${(BOSS_STATS.hpThresholds.normal * 100).toFixed(0)}%-${(BOSS_STATS.hpThresholds.fast * 100).toFixed(0)}%)`;
                else if (hpPercent > BOSS_STATS.hpThresholds.tank) phaseText = `阶段 3 (${(BOSS_STATS.hpThresholds.fast * 100).toFixed(0)}%-${(BOSS_STATS.hpThresholds.tank * 100).toFixed(0)}%)`;
                else phaseText = `阶段 4 (<${(BOSS_STATS.hpThresholds.tank * 100).toFixed(0)}%)`;
                bossPhaseDisplay.textContent = phaseText;


            } else {
                middleStatsTitle.textContent = "当前波数僵尸属性"; middleStatsTitle.style.display = 'block';
                zombieTypeStatContainers.forEach(c => c.style.display = 'block'); bossStatsDisplay.style.display = 'none';
                zombieStatsNote.style.display = 'block';
                zombieStatsNote.textContent = "";
                for (const typeKey in ZOMBIE_TYPES) {
                    const baseZombie = ZOMBIE_TYPES[typeKey];
                    const stats = getZombieStatsForWave(baseZombie, typeKey, wave);

                    if (typeKey === 'normal') { zombieNormalHpDisplay.textContent = stats.hp.toFixed(0); zombieNormalDamageDisplay.textContent = stats.damage.toFixed(0); zombieNormalSpeedDisplay.textContent = stats.speed.toFixed(2); }
                    else if (typeKey === 'fast') { zombieFastHpDisplay.textContent = stats.hp.toFixed(0); zombieFastDamageDisplay.textContent = stats.damage.toFixed(0); zombieFastSpeedDisplay.textContent = stats.speed.toFixed(2); }
                    else if (typeKey === 'tank') { zombieTankHpDisplay.textContent = stats.hp.toFixed(0); zombieTankDamageDisplay.textContent = stats.damage.toFixed(0); zombieTankSpeedDisplay.textContent = stats.speed.toFixed(2); }
                }
            }
        }

        function advanceWave() {
            wave++;
            playSound('waveStart');
            if (autoChangeBackground && wave > 1 && wave % 10 === 0 && nextBackgroundImage) {
                if (backgroundImage !== nextBackgroundImage) {
                    oldBackgroundImage = backgroundImage;
                    if (oldBackgroundImage && oldBackgroundImage.src) oldBackgroundImage.src = '';
                }
                backgroundImage = nextBackgroundImage;
                backgroundImageProcessed = true;
                crossfadeProgress = 0;
                nextBackgroundImage = null;
                fetchNextBackgroundImage();
            } else if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) {
                fetchNextBackgroundImage();
            }

            if (currentBoss && currentBoss.hp > 0) return;
            currentBoss = null; bossSummons = [];
            if (wave > 0 && wave % 10 === 0) { zombies = []; spawnBoss(); }
            else {
                let numZombiesToSpawn;
                const numZombiesBase = 5;
                if (wave <= 100) {
                    numZombiesToSpawn = numZombiesBase + wave * 2;
                } else if (wave <= 400) {
                    numZombiesToSpawn = numZombiesBase + 100 * 2 + (wave - 100) * 4;
                } else {
                    numZombiesToSpawn = numZombiesBase + 100 * 2 + 300 * 4 + (wave - 400) * 10; // 400波后僵尸数量进一步大幅增长
                }
                for (let i = 0; i < numZombiesToSpawn; i++) spawnZombie();
            }
            updateUI();
        }

        function spawnZombie(typeKeyOverride = null, count = 1, isBossSummon = false) {
            for (let k=0; k < count; k++) {
                let x, y; const edge = Math.floor(Math.random() * 4);
                const spawnMargin = BASE_CANVAS_WIDTH * 0.0375;

                if (edge === 0) { x = Math.random() * BASE_CANVAS_WIDTH; y = -spawnMargin; }
                else if (edge === 1) { x = BASE_CANVAS_WIDTH + spawnMargin; y = Math.random() * BASE_CANVAS_HEIGHT; }
                else if (edge === 2) { x = Math.random() * BASE_CANVAS_WIDTH; y = BASE_CANVAS_HEIGHT + spawnMargin; }
                else { x = -spawnMargin; y = Math.random() * BASE_CANVAS_HEIGHT; }

                let typeKey = typeKeyOverride;
                if (!typeKey) {
                    typeKey = 'normal'; const randType = Math.random();
                     // 随着波次增加，快速型和坦克型的出现概率越来越高
                    if (wave > 5 && randType > 0.6) typeKey = 'fast'; 
                    if (wave > 10 && randType > 0.8) typeKey = 'tank';
                    if (wave > 50 && randType > 0.4) typeKey = 'fast'; 
                    if (wave > 50 && randType > 0.7) typeKey = 'tank';
                    if (wave > 200 && randType > 0.2) typeKey = 'fast'; 
                    if (wave > 200 && randType > 0.5) typeKey = 'tank';
                    if (wave > 400 && randType > 0.1) typeKey = 'fast'; 
                    if (wave > 400 && randType > 0.3) typeKey = 'tank';
                }
                const type = ZOMBIE_TYPES[typeKey];
                const stats = getZombieStatsForWave(type, typeKey, wave);
                const newEnemy = { id: nextUniqueId++, x, y, hp: stats.hp, maxHp: stats.hp, speed: stats.speed, damage: stats.damage, xp: type.xp, color: type.color, size: type.size, type: typeKey, slowUntil: 0, originalSpeed: stats.speed, isBossSummon: isBossSummon };

                if (isBossSummon) {
                    bossSummons.push(newEnemy);
                } else {
                    zombies.push(newEnemy);
                }
            }
        }

        function generateBossPath() {
            const path = [];
            const margin = currentBoss.size * 0.7;
            const innerMarginFactor = 2.8;
            const innerClearance = player.size * innerMarginFactor + currentBoss.size;

            const outerRadiusX = (BASE_CANVAS_WIDTH / 2) - margin;
            const outerRadiusY = (BASE_CANVAS_HEIGHT / 2) - margin;
            const innerRadiusX = Math.max(currentBoss.size * 1.2, (BASE_CANVAS_WIDTH / 2) - innerClearance);
            const innerRadiusY = Math.max(currentBoss.size * 1.2, (BASE_CANVAS_HEIGHT / 2) - innerClearance);
            const centerX = BASE_CANVAS_WIDTH / 2;
            const centerY = BASE_CANVAS_HEIGHT / 2;

            const startAngle = Math.random() * Math.PI * 2;
            const pointsPerSegment = BOSS_STATS.pointsPerCircle;


            for (let i = 0; i <= pointsPerSegment; i++) {
                const angle = startAngle + (i / pointsPerSegment) * Math.PI * 2;
                path.push({ x: centerX + Math.cos(angle) * outerRadiusX, y: centerY + Math.sin(angle) * outerRadiusY, segment: 'outer' });
            }


            const lastOuterPoint = path[path.length-1];
            const firstInnerAngle = Math.atan2(lastOuterPoint.y - centerY, lastOuterPoint.x - centerX) + Math.PI;

            for (let i = 0; i <= pointsPerSegment; i++) {
                 const angle = firstInnerAngle - (i / pointsPerSegment) * Math.PI * 2;
                path.push({ x: centerX + Math.cos(angle) * innerRadiusX, y: centerY + Math.sin(angle) * innerRadiusY, segment: 'inner' });
            }
            return path;
        }


        function spawnBoss() {
            playSound('bossSpawn');
            const bossLevelMultiplier = Math.max(1, Math.floor(wave / 10)); 

            // 基础成长率
            let bossHpMultiplier = 1.0 + bossLevelMultiplier * 0.7; // 更快的生命值增长
            let bossSpeedMultiplier = 1.0 + bossLevelMultiplier * 0.08; // 更快的速度增长
            let bossDamageMultiplier = 1.0 + bossLevelMultiplier * 0.15; // 额外增加伤害乘数

            // 特殊波次加速
            if (wave > 50) {
                const wavesAfter50 = wave - 50;
                bossHpMultiplier += wavesAfter50 * 0.1; // 50波后生命值额外增加
                bossSpeedMultiplier += wavesAfter50 * 0.005; // 50波后速度额外增加
                bossDamageMultiplier += wavesAfter50 * 0.01; // 50波后伤害额外增加
            }

            if (wave > 200) {
                const wavesAfter200 = wave - 200;
                bossHpMultiplier += wavesAfter200 * 0.2; // 200波后生命值再次加速
                bossSpeedMultiplier += wavesAfter200 * 0.01; // 200波后速度再次加速
                bossDamageMultiplier += wavesAfter200 * 0.02; // 200波后伤害再次加速
            }
            
            // 400波后Boss成长显著提升
            if (wave > 400) {
                const post400Waves = wave - 400;
                bossHpMultiplier += post400Waves * 1.5; 
                bossSpeedMultiplier += post400Waves * 0.025; 
                bossDamageMultiplier += post400Waves * 0.05; 
            } 

            const baseSpeed = BOSS_STATS.baseSpeed * bossSpeedMultiplier;

            currentBoss = {
                id: BOSS_STATS.id,
                hp: BOSS_STATS.baseHp * bossHpMultiplier,
                maxHp: BOSS_STATS.baseHp * bossHpMultiplier,
                color: BOSS_STATS.color,
                size: BOSS_STATS.size,
                damage: (BOSS_STATS.damage * bossDamageMultiplier), // 使用新的伤害乘数
                xp: BOSS_STATS.baseXp * (1 + bossLevelMultiplier * 0.5),
                speed: baseSpeed,
                originalSpeed: baseSpeed,
                pathSegments: [],
                currentPathTargetIndex: 0,
                summonCooldowns: { normal: false, fast: false, tank: false },
                hpThresholds: { ...BOSS_STATS.hpThresholds },
                finalSpeedMultiplier: BOSS_STATS.finalSpeedMultiplier,
                pathState: 'outer_circle',
                finalApproachBaseSpeed: BOSS_STATS.finalApproachBaseSpeed * bossSpeedMultiplier,
                phaseEntered: { normal: false, fast: false, tank: false },
                finalSpeedBoostApplied: false,
            };
            currentBoss.pathSegments = generateBossPath();
            currentBoss.x = currentBoss.pathSegments[0].x;
            currentBoss.y = currentBoss.pathSegments[0].y;

            bossSummons = [];
            
            // 确保Boss伤害至少是玩家最大生命值的一部分，以保证威胁
            // 或保持其根据僵尸属性的倍数关系，但提高倍数
            const currentWaveNormalZombieStats = getZombieStatsForWave(ZOMBIE_TYPES.normal, 'normal', wave); 
            currentBoss.damage = Math.max(currentBoss.damage, currentWaveNormalZombieStats.damage * 15); // 提高倍数到15
        }

        function drawPlayer() {
            if (!player) return;
            const x = player.x;
            const y = player.y;
            const size = player.size;
            const halfSize = size / 2;
            const cornerRadius = size * 0.25;

            ctx.beginPath();
            ctx.moveTo(x - halfSize + cornerRadius, y - halfSize);
            ctx.lineTo(x + halfSize - cornerRadius, y - halfSize);
            ctx.arcTo(x + halfSize, y - halfSize, x + halfSize, y - halfSize + cornerRadius, cornerRadius);
            ctx.lineTo(x + halfSize, y + halfSize - cornerRadius);
            ctx.arcTo(x + halfSize, y + halfSize, x + halfSize - cornerRadius, y + halfSize, cornerRadius);
            ctx.lineTo(x - halfSize + cornerRadius, y + halfSize);
            ctx.arcTo(x - halfSize, y + halfSize, x - halfSize, y + halfSize - cornerRadius, cornerRadius);
            ctx.lineTo(x - halfSize, y - halfSize + cornerRadius);
            ctx.arcTo(x - halfSize, y - halfSize, x - halfSize + cornerRadius, y - halfSize, cornerRadius);
            ctx.closePath();

            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.stroke();


            const enemiesForTargeting = zombies.concat(bossSummons);
            if(currentBoss && currentBoss.hp > 0) enemiesForTargeting.push(currentBoss);
            const nearestTarget = findNearestZombie(player.x, player.y, enemiesForTargeting);

            if (nearestTarget) {
                const angle = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x);
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                const barrelLength = size * 0.7;
                const barrelWidth = size * 0.3;
                const barrelBaseOffset = size * 0.1;

                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(barrelBaseOffset, -barrelWidth / 2, barrelLength, barrelWidth);
                ctx.strokeStyle = '#7f8c8d';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(barrelBaseOffset, -barrelWidth / 2, barrelLength, barrelWidth);

                ctx.restore();
            }
        }

        function drawZombiesAndSummons() {
            const allEnemies = zombies.concat(bossSummons);
            allEnemies.forEach(enemy => {
                const x = enemy.x;
                const y = enemy.y;
                const size = enemy.size;
                const halfSize = size / 2;

                ctx.save();
                ctx.translate(x,y);

                const eyeRadius = size * 0.08;
                let eyeColor = 'rgba(0,0,0,0.7)';
                let pupilColor = 'rgba(255,0,0,0.8)';
                const pupilRadius = eyeRadius * 0.5;

                let bodyColor = enemy.color;
                let strokeColor;

                if (enemy.isBossSummon) {

                    pupilColor = '#c0392b';
                    eyeColor = 'rgba(50,0,0,0.8)';

                }

                if (enemy.type === 'normal') {
                    const bodyWidth = size;
                    const bodyHeight = size * 1.1;
                    const cornerRadius = size * 0.3;
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    if (ctx.roundRect) {
                         ctx.roundRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight, [cornerRadius]);
                    } else {
                        const r = cornerRadius; const w = bodyWidth; const h = bodyHeight; const bx = -bodyWidth/2; const by = -bodyHeight/2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    strokeColor = enemy.isBossSummon ? '#5c3e70' : '#1e8449';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();


                    ctx.fillStyle = eyeColor;
                    ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, pupilRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, pupilRadius*1.2, 0, Math.PI*2); ctx.fill();
                }
                else if (enemy.type === 'fast') {
                    const bodyWidth = size * 0.8;
                    const bodyHeight = size * 1.2;
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    strokeColor = enemy.isBossSummon ? '#b09000' : '#c29d0b';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();


                    ctx.fillStyle = eyeColor;
                    ctx.beginPath(); ctx.ellipse(-size*0.12, -size*0.15, eyeRadius, eyeRadius*1.5, -Math.PI/6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(size*0.12, -size*0.15, eyeRadius, eyeRadius*1.5, Math.PI/6, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(-size*0.12, -size*0.15, pupilRadius, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.12, -size*0.15, pupilRadius, 0, Math.PI*2); ctx.fill();
                }
                else if (enemy.type === 'tank') {
                    const bodyWidth = size * 1.3;
                    const bodyHeight = size * 1.1;
                    const cornerRadius = size * 0.2;
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                     if (ctx.roundRect) {
                        ctx.roundRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight, [cornerRadius]);
                    } else {
                        const r = cornerRadius; const w = bodyWidth; const h = bodyHeight; const bx = -bodyWidth/2; const by = -bodyHeight/2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    strokeColor = enemy.isBossSummon ? '#8B0000' : '#962d22';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 2;
                    ctx.stroke();


                    ctx.fillStyle = 'rgba(50,50,50,0.8)';
                    ctx.beginPath();
                    if (ctx.roundRect) {
                         ctx.roundRect(-size*0.25, -size*0.2, size*0.5, size*0.3, [size*0.05]);
                    } else {
                        const r = size*0.05; const w = size*0.5; const h = size*0.3; const bx = -size*0.25; const by = -size*0.2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(0, -size*0.05, eyeRadius*1.5, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();


                if (enemy.hp < enemy.maxHp) {
                    const barWidth = size * 1.2;
                    const barHeight = 4;
                    const barYOffset = halfSize * 1.2 + barHeight;

                    ctx.fillStyle = 'rgba(192, 57, 43, 0.7)';
                    ctx.fillRect(enemy.x - barWidth / 2, enemy.y - barYOffset, barWidth, barHeight);
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.9)';
                    ctx.fillRect(enemy.x - barWidth / 2, enemy.y - barYOffset, barWidth * (enemy.hp / enemy.maxHp), barHeight);
                }
            });
        }

        function drawBoss() {
            if (!currentBoss || currentBoss.hp <= 0) return;
            const x = currentBoss.x;
            const y = currentBoss.y;
            const size = currentBoss.size;
            const hpPercent = currentBoss.hp / currentBoss.maxHp;
            const halfSize = size / 2;

            ctx.save();
            ctx.translate(x, y);

            let bodyColor = currentBoss.color;
            let strokeColor = '#542e71';


            if (hpPercent <= BOSS_STATS.hpThresholds.tank) {
                bodyColor = '#c0392b';
                strokeColor = '#782419';
            } else if (hpPercent <= BOSS_STATS.hpThresholds.fast) {
                bodyColor = '#f39c12';
                strokeColor = '#b0720f';
            } else if (hpPercent <= BOSS_STATS.hpThresholds.normal){
                bodyColor = '#27ae60';
                strokeColor = '#1e8449';
            }


            const bodyWidth = size * 1.0;
            const bodyHeight = size * 1.1;
            const cornerRadius = size * 0.3;

            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            if (ctx.roundRect) {
                 ctx.roundRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight, [cornerRadius]);
            } else {
                const r = cornerRadius; const w = bodyWidth; const h = bodyHeight; const bx = -bodyWidth/2; const by = -bodyHeight/2;
                ctx.moveTo(bx + r, by);
                ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                ctx.closePath();
            }
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2.5;
            ctx.stroke();


            const eyeRadius = size * 0.1;
            let eyeColorOuter = 'rgba(255,255,255,0.9)';
            let eyeColorInner = 'rgba(0,0,0,0.8)';
            let pupilColor = 'rgba(255,50,50,0.9)';
            const pupilRadius = eyeRadius * 0.5;

            if (hpPercent <= BOSS_STATS.hpThresholds.tank) {
                pupilColor = 'rgba(255,0,0,1)';
                eyeColorInner = 'rgba(50,0,0,0.9)';
            }



            ctx.fillStyle = eyeColorOuter;
            ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = eyeColorInner;
            ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, eyeRadius*0.9, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, eyeRadius*0.9, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = pupilColor;
            ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, pupilRadius*1.1, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, pupilRadius*1.1, 0, Math.PI*2); ctx.fill();


            ctx.restore();


            if (currentBoss.hp < currentBoss.maxHp) {
                const barWidth = currentBoss.size * 1.3;
                const barHeight = 10;
                const barY = currentBoss.y - currentBoss.size * 0.7 - barHeight;

                ctx.fillStyle = 'rgba(192, 57, 43, 0.7)';
                ctx.fillRect(currentBoss.x - barWidth / 2, barY, barWidth, barHeight);
                ctx.fillStyle = 'rgba(46, 204, 113, 0.9)';
                ctx.fillRect(currentBoss.x - barWidth / 2, barY, barWidth * (Math.max(0, currentBoss.hp) / currentBoss.maxHp), barHeight);
            }
        }


        function drawWindBlades() {
            windBlades.forEach(blade => {
                ctx.save();
                ctx.translate(blade.x, blade.y);
                ctx.rotate(blade.angle);
                ctx.fillStyle = 'rgba(175, 225, 255, 0.65)';
                ctx.strokeStyle = 'rgba(60, 150, 220, 0.9)';
                ctx.lineWidth = 1.5;


                const bladeLength = 25 * blade.sizeMultiplier;
                const bladeOuterWidth = 8 * blade.sizeMultiplier;
                const bladeInnerWidth = -4 * blade.sizeMultiplier;

                ctx.beginPath();

                ctx.moveTo(0, -bladeLength / 2);

                ctx.quadraticCurveTo(bladeOuterWidth, 0, 0, bladeLength / 2);

                ctx.quadraticCurveTo(bladeInnerWidth, 0, 0, -bladeLength / 2);
                ctx.closePath();

                ctx.fill();
                ctx.stroke();
                ctx.restore();
            });
        }


        function drawBullets() { bullets.forEach(bullet => { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2); ctx.fill(); }); }

        function drawSlimes() {
            if (!player || !player.slimes) return;
            player.slimes.forEach(slime => {
                const x = slime.x;
                const y = slime.y;
                const radius = slime.size;

                const baseSlimeColor = slime.color || 'rgba(52, 152, 219, 0.7)';
                const darkerSlimeColor = 'rgba(41, 128, 185, 0.8)';
                const highlightColor1 = 'rgba(174, 214, 241, 0.7)';
                const highlightColor2 = 'rgba(255, 255, 255, 0.4)';

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);

                let grad = ctx.createRadialGradient(x - radius * 0.3, y - radius * 0.3, radius * 0.1, x, y, radius);
                grad.addColorStop(0, highlightColor1);
                grad.addColorStop(0.8, baseSlimeColor);
                grad.addColorStop(1, darkerSlimeColor);
                ctx.fillStyle = grad;
                ctx.fill();


                ctx.beginPath();
                ctx.ellipse(x - radius * 0.4, y - radius * 0.5, radius * 0.25, radius * 0.15, Math.PI / -4, 0, Math.PI * 2);
                ctx.fillStyle = highlightColor2;
                ctx.fill();

                ctx.beginPath();
                ctx.ellipse(x + radius * 0.3, y - radius * 0.2, radius * 0.15, radius * 0.08, Math.PI / 4, 0, Math.PI * 2);
                ctx.fillStyle = highlightColor2;
                ctx.fill();
            });
        }

        function drawEnergyWaves() {
            energyWaves.forEach(wave => {
                const x = wave.x;
                const y = wave.y;
                const radius = wave.radius;
                const baseThickness = wave.thickness;
                const baseColorString = wave.color;


                let r = 255, g = 100, b = 0, a = 0.6;
                const match = baseColorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (match) {
                    r = parseInt(match[1]); g = parseInt(match[2]); b = parseInt(match[3]);
                    a = match[4] ? parseFloat(match[4]) : 1;
                }



                ctx.strokeStyle = `rgba(${Math.min(255,r+80)}, ${Math.min(255,g+80)}, ${Math.min(255,b+50)}, ${Math.min(1, a + 0.3)})`;
                ctx.lineWidth = baseThickness * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, radius - baseThickness * 0.75, 0, Math.PI * 2);
                ctx.stroke();


                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.lineWidth = baseThickness;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();


                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a * 0.4})`;
                ctx.lineWidth = baseThickness * 1.2;
                ctx.beginPath();
                ctx.arc(x, y, radius + baseThickness * 0.75, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function findNearestZombie(fromX, fromY, enemyList) { let nearest = null; let minDist = Infinity; enemyList.forEach(enemy => { if (enemy.hp <= 0) return; const dist = Math.hypot(enemy.x - fromX, enemy.y - fromY); if (dist < minDist) { minDist = dist; nearest = enemy; } }); return nearest; }

        function fireOneSetOfBullets(currentTime) {
            if (!player) return;

            const enemiesForTargeting = zombies.concat(bossSummons);
            if(currentBoss && currentBoss.hp > 0) enemiesForTargeting.push(currentBoss);
            const nearestTarget = findNearestZombie(player.x, player.y, enemiesForTargeting);

            if (!nearestTarget) return;
            playSound('shoot');
            const angleToTarget = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x); const bulletDamage = calculateBulletDamage();
            const projectileSpread = player.projectileCount > 1 ? Math.PI / (9 + player.projectileCount * 1.5) : 0; let fanCenterAngle = angleToTarget;
            if (player.projectileCount > 1 && player.projectileCount % 2 === 0) fanCenterAngle -= projectileSpread / 2;
            for (let i = 0; i < player.projectileCount; i++) { const currentAngle = fanCenterAngle - (projectileSpread * (player.projectileCount - 1) / 2) + (i * projectileSpread); const bulletSpawnDist = player.size * 0.5; const offsetX = Math.cos(currentAngle) * bulletSpawnDist; const offsetY = Math.sin(currentAngle) * bulletSpawnDist; bullets.push({ x: player.x + offsetX, y: player.y + offsetY, dx: Math.cos(currentAngle) * 7, dy: Math.sin(currentAngle) * 7, damage: bulletDamage, pierceRemaining: player.bulletPierceCount, hitTargets: new Set() }); }
            timeOfLastBurstBullet = currentTime;
        }

        function fireWindBlades(currentTime) {
            if (!player.hasWindBlade || player.windBladeCount <= 0) return;

            const numBlades = player.windBladeCount;
            const damage = calculateWindBladeDamage();
            const slowPercent = calculateWindBladeSlowPercent();
            const slowDuration = calculateWindBladeSlowDuration();
            const sizeMultiplier = player.windBladeSizeMultiplier;
            const bladeSpeed = 4;


            const enemiesForTargeting = zombies.concat(bossSummons);
            if(currentBoss && currentBoss.hp > 0) enemiesForTargeting.push(currentBoss);
            const nearestTarget = findNearestZombie(player.x, player.y, enemiesForTargeting);

            let baseAngle = Math.random() * Math.PI * 2;
            if(nearestTarget){
                baseAngle = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x);
            }

            const angleStep = numBlades > 1 ? (Math.PI / 5) / (numBlades -1) : 0;

            for(let i = 0; i < numBlades; i++){
                const currentAngle = baseAngle - (angleStep * (numBlades - 1) / 2) + (i * angleStep);
                windBlades.push({
                    id: nextUniqueId++,
                    x: player.x, y: player.y,
                    dx: Math.cos(currentAngle) * bladeSpeed,
                    dy: Math.sin(currentAngle) * bladeSpeed,
                    angle: currentAngle,
                    damage: damage,
                    slowPercent: slowPercent,
                    slowDurationMs: slowDuration * 1000,
                    sizeMultiplier: sizeMultiplier,
                    hitTargets: new Set(),
                    lifespan: 3500,
                    spawnTime: currentTime
                });
            }
            player.lastWindBladeTime = currentTime;
        }


        function updatePlayer(currentTime) {
            if (skillSelectionActive || skillBookOpen || bossRewardModalActive || !player || !gameRunning) return;

            player.x = Math.max(player.size / 2, Math.min(BASE_CANVAS_WIDTH - player.size / 2, player.x));
            player.y = Math.max(player.size / 2, Math.min(BASE_CANVAS_HEIGHT - player.size / 2, player.y));

            if (player.hpRegenPer5Sec > 0 && currentTime - player.lastHpRegenTime > 5000) { player.hp = Math.min(player.hp + player.hpRegenPer5Sec, player.maxHp); player.lastHpRegenTime = currentTime; updateUI(); }
            if (player.currentBulletInBurst === 0 && currentTime - lastShotTime > player.shootCooldown) { fireOneSetOfBullets(currentTime); lastShotTime = currentTime; player.currentBulletInBurst = 1; }
            else if (player.currentBulletInBurst > 0 && player.currentBulletInBurst < player.bulletsPerShot && currentTime - timeOfLastBurstBullet > INTER_BULLET_DELAY) { fireOneSetOfBullets(currentTime); player.currentBulletInBurst++; }
            if (player.currentBulletInBurst >= player.bulletsPerShot) player.currentBulletInBurst = 0;
            if (player.hasEnergyWave && currentTime - player.lastEnergyWaveTime > player.energyWaveCooldown) {
                playSound('energyWaveFire');
                energyWaves.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT) * 0.8, speed: 0.8, thickness: 3, color: 'rgba(255, 100, 0, 0.6)', damage: calculateEnergyWaveDamage(), hitZombies: new Set() }); player.lastEnergyWaveTime = currentTime;
            }

            if (player.hasWindBlade && currentTime - player.lastWindBladeTime > player.windBladeCooldown) {
                fireWindBlades(currentTime);

            }
        }

        function updateSlimes(currentTime) {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !player || !player.slimes || player.slimes.length === 0 || !gameRunning) return;

            const slimeDamage = calculateSlimeDamage();

            const allLiveEnemies = [];
            if (currentBoss && currentBoss.hp > 0) {
                allLiveEnemies.push({ enemy: currentBoss, isBoss: true, id: currentBoss.id, targetedBySlimeCount: 0 });
            }
            zombies.concat(bossSummons).forEach(e => {
                if (e.hp > 0) {
                    allLiveEnemies.push({ enemy: e, isBoss: false, id: e.id, targetedBySlimeCount: 0 });
                }
            });

            if (allLiveEnemies.length === 0) {
                player.slimes.forEach(slime => {
                    slime.targetEnemyId = null;
                    slime.targetIsBoss = false;
                });
                return;
            }

            player.slimes.forEach(slime => {
                if (slime.targetEnemyId !== null) {
                    const currentTargetInfo = allLiveEnemies.find(ei => ei.id === slime.targetEnemyId);
                    if (currentTargetInfo && currentTargetInfo.enemy.hp > 0) {
                        currentTargetInfo.targetedBySlimeCount++;
                    } else {
                        slime.targetEnemyId = null;
                        slime.targetIsBoss = false;
                    }
                }
            });

            player.slimes.forEach(slime => {
                if (slime.targetEnemyId === null && allLiveEnemies.length > 0) {
                    allLiveEnemies.sort((a, b) => {
                        if (a.targetedBySlimeCount !== b.targetedBySlimeCount) {
                            return a.targetedBySlimeCount - b.targetedBySlimeCount;
                        }
                        const distA = Math.hypot(a.enemy.x - slime.x, a.enemy.y - slime.y);
                        const distB = Math.hypot(b.enemy.x - slime.x, b.enemy.y - slime.y);
                        return distA - distB;
                    });

                    const bestTargetInfo = allLiveEnemies[0];
                    slime.targetEnemyId = bestTargetInfo.id;
                    slime.targetIsBoss = bestTargetInfo.isBoss;
                    bestTargetInfo.targetedBySlimeCount++;
                }
            });

            player.slimes.forEach(slime => {
                let currentTargetEnemy = null;
                if (slime.targetEnemyId !== null) {
                    if (slime.targetIsBoss && currentBoss && currentBoss.id === slime.targetEnemyId && currentBoss.hp > 0) {
                        currentTargetEnemy = currentBoss;
                    } else {
                        const regularEnemy = zombies.concat(bossSummons).find(e => e.id === slime.targetEnemyId && e.hp > 0);
                        if (regularEnemy) {
                            currentTargetEnemy = regularEnemy;
                        } else {
                            slime.targetEnemyId = null;
                            slime.targetIsBoss = false;
                        }
                    }
                }

                if (currentTargetEnemy) {
                    const slimeEffectiveSpeed = calculateCurrentSlimeSpeed(slime);
                    const angleToTarget = Math.atan2(currentTargetEnemy.y - slime.y, currentTargetEnemy.x - slime.x);
                    slime.x += Math.cos(angleToTarget) * slimeEffectiveSpeed;
                    slime.y += Math.sin(angleToTarget) * slimeEffectiveSpeed;

                    if (Math.hypot(slime.x - currentTargetEnemy.x, slime.y - currentTargetEnemy.y) < slime.size + currentTargetEnemy.size / 2) {
                        if (!slime.lastDamageApplicationTimes[currentTargetEnemy.id] || currentTime - slime.lastDamageApplicationTimes[currentTargetEnemy.id] > 1000) {
                            playSound('slimeAttack');
                            currentTargetEnemy.hp -= slimeDamage;
                            slime.lastDamageApplicationTimes[currentTargetEnemy.id] = currentTime;

                            if (currentTargetEnemy.hp <= 0) {
                                const deadEnemyId = currentTargetEnemy.id;
                                const enemyType = currentTargetEnemy.type;
                                const isSummon = currentTargetEnemy.isBossSummon;

                                if (slime.targetIsBoss) {
                                    handleBossDefeat();
                                } else {
                                    playSound('zombieDie');
                                    if (isSummon) {
                                        bossSummons = bossSummons.filter(s => s.id !== deadEnemyId);
                                    } else {
                                        zombies = zombies.filter(z => z.id !== deadEnemyId);
                                    }
                                    score += Math.floor((isSummon ? ZOMBIE_TYPES[enemyType].xp * 0.5 : ZOMBIE_TYPES[enemyType].xp) * player.xpGainMultiplier * 0.5);
                                }

                                player.slimes.forEach(s => {
                                    if (s.lastDamageApplicationTimes && s.lastDamageApplicationTimes[deadEnemyId]) {
                                        delete s.lastDamageApplicationTimes[deadEnemyId];
                                    }
                                    if (s.targetEnemyId === deadEnemyId) {
                                        s.targetEnemyId = null;
                                        s.targetIsBoss = false;
                                    }
                                });
                            }
                             updateUI();
                        }
                    }
                }
            });
        }


        function updateEnergyWaves() {
            if (!gameRunning) return;
            for (let i = energyWaves.length - 1; i >= 0; i--) {
                const wave = energyWaves[i]; wave.radius += wave.speed;
                if (wave.radius > wave.maxRadius) { energyWaves.splice(i, 1); continue; }
                const allTargets = zombies.concat(bossSummons);
                for (let j = allTargets.length - 1; j >= 0; j--) {
                    const enemy = allTargets[j]; if (!wave.hitZombies.has(enemy.id)) {
                        const dist = Math.hypot(enemy.x - wave.x, enemy.y - wave.y);
                        if (dist >= wave.radius - enemy.size / 2 - wave.thickness && dist <= wave.radius + enemy.size / 2 + wave.thickness) {
                            enemy.hp -= wave.damage; wave.hitZombies.add(enemy.id);
                            if (enemy.hp <= 0) {
                                playSound('zombieDie');
                                const deadEnemyId = enemy.id;
                                const enemyType = enemy.type;
                                const isSummon = enemy.isBossSummon;

                                if (isSummon) { bossSummons = bossSummons.filter(s => s.id !== deadEnemyId); }
                                else { zombies = zombies.filter(z => z.id !== deadEnemyId); }


                                score += Math.floor((isSummon ? ZOMBIE_TYPES[enemyType].xp * 0.5 : ZOMBIE_TYPES[enemyType].xp) * player.xpGainMultiplier * 0.75);



                                if (player && player.slimes) {
                                    player.slimes.forEach(s => {
                                        if (s.lastDamageApplicationTimes && s.lastDamageApplicationTimes[deadEnemyId]) {
                                            delete s.lastDamageApplicationTimes[deadEnemyId];
                                        }
                                         if (s.targetEnemyId === deadEnemyId) { s.targetEnemyId = null; s.targetIsBoss = false;}
                                    });
                                }
                                updateUI();
                            }
                        }
                    }
                }
                if (currentBoss && currentBoss.hp > 0 && !wave.hitZombies.has(currentBoss.id)) {
                    const dist = Math.hypot(currentBoss.x - wave.x, currentBoss.y - wave.y);
                    if (dist >= wave.radius - currentBoss.size / 2 - wave.thickness && dist <= wave.radius + currentBoss.size / 2 + wave.thickness) {
                        let damageToBoss = wave.damage;


                        currentBoss.hp -= damageToBoss; wave.hitZombies.add(currentBoss.id); updateUI();
                        if (currentBoss.hp <= 0) handleBossDefeat();
                    }
                }
            }
        }

        function updateEnemies(enemyList, currentTime) {
             if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !player || !gameRunning) return;
            for (let i = enemyList.length - 1; i >= 0; i--) {
                const enemy = enemyList[i];

                if (enemy.slowUntil && enemy.slowUntil <= currentTime && enemy.slowUntil !== 0) {
                    if (typeof enemy.originalSpeed === 'number') {
                        enemy.speed = enemy.originalSpeed;
                    }
                    enemy.slowUntil = 0;
                }


                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;


                if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < (player.size / 2 + enemy.size / 2)) {
                    playSound('playerHurt');
                    player.hp -= enemy.damage;

                    const baseXPFromEnemyObject = enemy.xp;
                    let xpToAward = baseXPFromEnemyObject * 0.5;
                    if (enemy.isBossSummon) {
                        xpToAward *= 0.5;
                    }
                    const gainedXp = Math.floor(xpToAward * player.xpGainMultiplier);

                    player.xp += gainedXp;
                    score += gainedXp;
                    checkLevelUp();

                    const deadEnemyId = enemy.id;
                    enemyList.splice(i, 1);


                    if (player && player.slimes) {
                        player.slimes.forEach(s => {
                            if (s.lastDamageApplicationTimes && s.lastDamageApplicationTimes[deadEnemyId]) {
                                delete s.lastDamageApplicationTimes[deadEnemyId];
                            }
                             if (s.targetEnemyId === deadEnemyId) {
                                s.targetEnemyId = null;
                                s.targetIsBoss = false;
                            }
                        });
                    }
                    if (player.hp <= 0) gameOver();
                    updateUI();
                }
            }
        }


        function updateBoss(currentTime) {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !currentBoss || !player || !gameRunning || currentBoss.hp <= 0) return;
            const hpPercent = currentBoss.hp / currentBoss.maxHp;

            triggerBossSummon('normal');
            currentBoss.phaseEntered.normal = true;

            if (hpPercent <= currentBoss.hpThresholds.normal && !currentBoss.phaseEntered.fast) {
                triggerBossSummon('fast');
                currentBoss.phaseEntered.fast = true;
            }
            if (hpPercent <= currentBoss.hpThresholds.fast && !currentBoss.phaseEntered.tank) {
                triggerBossSummon('tank');
                currentBoss.phaseEntered.tank = true;
            }
            if (hpPercent <= currentBoss.hpThresholds.tank && !currentBoss.finalSpeedBoostApplied) {
                currentBoss.speed = currentBoss.originalSpeed * currentBoss.finalSpeedMultiplier;
                currentBoss.finalSpeedBoostApplied = true;
            }


            let currentSpeed = currentBoss.finalSpeedBoostApplied ? currentBoss.speed : currentBoss.originalSpeed;
             if (currentBoss.pathState === 'final_approach' && !currentBoss.finalSpeedBoostApplied) {

                 currentSpeed = currentBoss.finalApproachBaseSpeed * (1.0 + Math.max(0, Math.floor(wave / 10) - 1) * 0.08);
            }



            if (currentBoss.pathState === 'outer_circle' || currentBoss.pathState === 'inner_circle') {
                const targetPoint = currentBoss.pathSegments[currentBoss.currentPathTargetIndex];
                const dx = targetPoint.x - currentBoss.x;
                const dy = targetPoint.y - currentBoss.y;
                const distToTarget = Math.hypot(dx, dy);

                if (distToTarget < currentSpeed + 5) {
                    currentBoss.currentPathTargetIndex++;
                    if (currentBoss.currentPathTargetIndex >= currentBoss.pathSegments.length) {

                        currentBoss.pathState = 'final_approach';
                    } else {

                        const nextSegmentType = currentBoss.pathSegments[currentBoss.currentPathTargetIndex].segment;
                        const currentSegmentType = currentBoss.pathSegments[currentBoss.currentPathTargetIndex-1].segment;
                        if (currentSegmentType === 'outer' && nextSegmentType === 'inner') {
                             currentBoss.pathState = 'inner_circle';
                        } else if (currentSegmentType === 'inner' && currentBoss.currentPathTargetIndex >= BOSS_STATS.pointsPerCircle * 2 + 1) {
                            currentBoss.pathState = 'final_approach';
                        }

                    }
                } else {
                    currentBoss.x += (dx / distToTarget) * currentSpeed;
                    currentBoss.y += (dy / distToTarget) * currentSpeed;
                }
            } else if (currentBoss.pathState === 'final_approach') {

                const dx = player.x - currentBoss.x;
                const dy = player.y - currentBoss.y;
                const distToPlayer = Math.hypot(dx, dy);
                if (distToPlayer > currentBoss.size / 2) {
                    currentBoss.x += (dx / distToPlayer) * currentSpeed;
                    currentBoss.y += (dy / distToPlayer) * currentSpeed;
                }
            }



            if (Math.hypot(player.x - currentBoss.x, player.y - currentBoss.y) < (player.size / 2 + currentBoss.size / 2) ) {
                 playSound('playerHurt');
                 player.hp = 0;
                 gameOver();
                 return;
            }
        }

        function triggerBossSummon(type) {
            if (currentBoss.summonCooldowns[type]) return;

            const bossInstanceLevel = Math.max(1, Math.floor(wave / 10));
            let baseSummonCount;

            if (bossInstanceLevel <= 5) { // 调整早期Boss召唤数量
                if (type === 'normal') {
                    baseSummonCount = 3 + bossInstanceLevel; 
                } else if (type === 'fast') {
                    baseSummonCount = Math.floor(0.8 * bossInstanceLevel); // 更早开始召唤快速型
                } else { 
                    baseSummonCount = (bossInstanceLevel >= 4) ? 1 : 0; // 40波开始召唤坦克
                }
            } else if (bossInstanceLevel <= 15) { // 调整中期Boss召唤数量
                const midLevelProgress = bossInstanceLevel - 5; 
                if (type === 'normal') {
                    baseSummonCount = 8 + Math.floor(midLevelProgress * 1.5); 
                } else if (type === 'fast') {
                    baseSummonCount = 2 + Math.floor(midLevelProgress * 1.2);   
                } else { 
                    baseSummonCount = 1 + Math.floor(midLevelProgress * 0.8);   
                }
            } else { // 调整后期Boss召唤数量
                const lateLevelProgress = bossInstanceLevel - 15; 
                if (type === 'normal') {
                    baseSummonCount = 20 + Math.floor(lateLevelProgress * 3.0); 
                } else if (type === 'fast') {
                    baseSummonCount = 10 + Math.floor(lateLevelProgress * 2.5);    
                } else { 
                    baseSummonCount = 8 + Math.floor(lateLevelProgress * 2.0);    
                }
            }

            let quantityMultiplier = 1.0;
            if (bossInstanceLevel <= 3) {
                quantityMultiplier = 1.0; 
            } else if (bossInstanceLevel <= 10) { 
                quantityMultiplier = 1.2 + (bossInstanceLevel - 3) * 0.05; 
            } else { 
                quantityMultiplier = 1.5 + (bossInstanceLevel - 10) * 0.08; 
            }

            let finalSummonCount = Math.floor(baseSummonCount * quantityMultiplier);
            finalSummonCount = Math.max(0, finalSummonCount);

            if (type === 'tank' && bossInstanceLevel < 4) finalSummonCount = 0; 

            if (finalSummonCount > 0) {
                spawnZombie(type, finalSummonCount, true);
            }
            currentBoss.summonCooldowns[type] = true;
        }


        function updateWindBlades(currentTime) {
            for (let i = windBlades.length - 1; i >= 0; i--) {
                const blade = windBlades[i];
                blade.x += blade.dx;
                blade.y += blade.dy;



                if (currentTime - blade.spawnTime > blade.lifespan ||
                    blade.x < -20 || blade.x > BASE_CANVAS_WIDTH + 20 ||
                    blade.y < -20 || blade.y > BASE_CANVAS_HEIGHT + 20) {
                    windBlades.splice(i, 1);
                    continue;
                }

                const allTargets = zombies.concat(bossSummons).concat(currentBoss && currentBoss.hp > 0 ? [currentBoss] : []);
                for (let j = allTargets.length - 1; j >=0; j--) {
                    const enemy = allTargets[j];
                    if (blade.hitTargets.has(enemy.id)) continue;

                    const bladeEffectiveSize = 15 * blade.sizeMultiplier;
                    if (Math.hypot(blade.x - enemy.x, blade.y - enemy.y) < (enemy.size / 2 + bladeEffectiveSize / 2)) {
                        enemy.hp -= blade.damage;
                        blade.hitTargets.add(enemy.id);


                        if (enemy !== currentBoss) {
                            if (typeof enemy.originalSpeed === 'number') {
                                enemy.speed = enemy.originalSpeed * (1 - blade.slowPercent);
                                enemy.slowUntil = currentTime + blade.slowDurationMs;
                            }
                        }

                        if (enemy.hp <= 0) {
                            playSound('zombieDie');
                            const deadEnemyId = enemy.id;
                            const enemyType = enemy.type;
                            const isSummon = enemy.isBossSummon;

                            if (enemy === currentBoss) { handleBossDefeat(); }
                            else if (isSummon) { bossSummons = bossSummons.filter(s => s.id !== deadEnemyId); }
                            else { zombies = zombies.filter(z => z.id !== deadEnemyId); }

                            const gainedXp = Math.floor((isSummon ? ZOMBIE_TYPES[enemyType].xp * 0.5 : ZOMBIE_TYPES[enemyType].xp) * player.xpGainMultiplier);
                            player.xp += gainedXp; score += gainedXp;


                            if (player && player.slimes) {
                                player.slimes.forEach(s => {
                                    if (s.lastDamageApplicationTimes && s.lastDamageApplicationTimes[deadEnemyId]) {
                                        delete s.lastDamageApplicationTimes[deadEnemyId];
                                    }
                                     if (s.targetEnemyId === deadEnemyId) { s.targetEnemyId = null; s.targetIsBoss = false;}
                                });
                            }
                            checkLevelUp(); updateUI();
                        }

                    }
                }
            }
        }


        function updateBullets() {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !gameRunning) return;
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; bullet.x += bullet.dx; bullet.y += bullet.dy;
                if (!bullet.hitTargets) bullet.hitTargets = new Set();
                if (bullet.x < -50 || bullet.x > BASE_CANVAS_WIDTH + 50 || bullet.y < -50 || bullet.y > BASE_CANVAS_HEIGHT + 50) {
                    bullets.splice(i, 1); continue;
                }
                let bulletRemovedThisIteration = false;
                const allTargets = zombies.concat(bossSummons);
                for (let j = allTargets.length - 1; j >= 0; j--) {
                    if (bulletRemovedThisIteration) break; const enemy = allTargets[j]; if (bullet.hitTargets.has(enemy.id)) continue;
                    if (Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < (enemy.size / 2 + 3)) {
                        enemy.hp -= bullet.damage; bullet.hitTargets.add(enemy.id);
                        if (enemy.hp <= 0) {
                            playSound('zombieDie');
                            const deadEnemyId = enemy.id;
                            const enemyType = enemy.type;
                            const isSummon = enemy.isBossSummon;

                            if (isSummon) { bossSummons = bossSummons.filter(s => s.id !== deadEnemyId); }
                            else { zombies = zombies.filter(z => z.id !== deadEnemyId); }

                            const gainedXp = Math.floor((isSummon ? ZOMBIE_TYPES[enemyType].xp * 0.5 : ZOMBIE_TYPES[enemyType].xp) * player.xpGainMultiplier);
                            player.xp += gainedXp; score += gainedXp;


                            if (player && player.slimes) {
                                player.slimes.forEach(s => {
                                    if (s.lastDamageApplicationTimes && s.lastDamageApplicationTimes[deadEnemyId]) {
                                        delete s.lastDamageApplicationTimes[deadEnemyId];
                                    }
                                     if (s.targetEnemyId === deadEnemyId) { s.targetEnemyId = null; s.targetIsBoss = false;}
                                });
                            }
                            checkLevelUp(); updateUI();
                        }
                        if (bullet.pierceRemaining > 0) bullet.pierceRemaining--; else { bullets.splice(i, 1); bulletRemovedThisIteration = true; }
                    }
                }
                if (bulletRemovedThisIteration) continue;
                if (currentBoss && currentBoss.hp > 0 && !bullet.hitTargets.has(currentBoss.id)) {
                    if (Math.hypot(bullet.x - currentBoss.x, bullet.y - currentBoss.y) < (currentBoss.size / 2 + 3)) {
                        let actualDamage = bullet.damage;


                        currentBoss.hp -= actualDamage;
                        bullet.hitTargets.add(currentBoss.id); updateUI();
                        if (currentBoss.hp <= 0) handleBossDefeat();
                        if (bullet.pierceRemaining > 0) bullet.pierceRemaining--; else bullets.splice(i, 1);
                    }
                }
            }
        }

        function handleBossDefeat() {
            if (!currentBoss) return;
            playSound('bossDie');
            if (activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
                activeBossSpawnSound = null;
            }
            const defeatedBossId = currentBoss.id;
            const bossXp = Math.floor(currentBoss.xp * player.xpGainMultiplier);
            score += bossXp; player.xp += bossXp;
            checkLevelUp();

            currentBoss = null;

            bossSummons.forEach(s => {
                 if (player && player.slimes) {
                    player.slimes.forEach(ps => {
                        if (ps.lastDamageApplicationTimes && ps.lastDamageApplicationTimes[s.id]) {
                            delete ps.lastDamageApplicationTimes[s.id];
                        }
                    });
                }
            });
            bossSummons = [];



            if (player && player.slimes) {
                player.slimes.forEach(slime => {
                    if (slime.lastDamageApplicationTimes && slime.lastDamageApplicationTimes[defeatedBossId]) {
                        delete slime.lastDamageApplicationTimes[defeatedBossId];
                    }
                    if (slime.targetEnemyId === defeatedBossId) {
                        slime.targetEnemyId = null;
                        slime.targetIsBoss = false;
                    }
                });
            }

            const grantedSkills = [];
            let availableChoices = ALL_SKILLS.filter(skill => {
                const currentStacks = player.learnedSkills[skill.id] || 0;
                if (skill.maxStacks !== undefined && currentStacks >= skill.maxStacks) return false;
                if (skill.prerequisite && !(player.learnedSkills[skill.prerequisite] > 0)) return false;

                if (skill.id === 'xp_gain_boost' && player.xpGainMultiplier >= 2.0) return false;
                if (skill.id === 'slime_accelerate' && player.slimeSpeedMultiplier >= MAX_SLIME_SPEED_MULTIPLIER) return false;
                if (skill.id === 'energy_wave_cooldown_down' && player.energyWaveCooldown <= 10000) return false;

                return true;
            });
            for (let i = 0; i < 3 && availableChoices.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableChoices.length);
                const chosenSkill = availableChoices.splice(randomIndex, 1)[0];
                chosenSkill.apply(player);
                player.learnedSkills[chosenSkill.id] = (player.learnedSkills[chosenSkill.id] || 0) + 1;
                grantedSkills.push(chosenSkill);
            }
            if (grantedSkills.length > 0) playSound('skillAcquired');
            presentBossRewardModal(grantedSkills);
            updateUI();

        }

        function presentBossRewardModal(skills) {
            bossRewardModalActive = true; bossRewardSkillList.innerHTML = '';
            if (skills.length === 0) { bossRewardSkillList.innerHTML = '<p>没有可授予的新技能。</p>'; }
            else { const ul = document.createElement('ul'); skills.forEach(skill => { const li = document.createElement('li'); li.textContent = skill.name; ul.appendChild(li); }); bossRewardSkillList.appendChild(ul); }
            bossRewardModal.style.display = 'block'; let timeLeft = 6; bossRewardTimerDisplay.textContent = `关闭倒计时: ${timeLeft}s`;
            if (bossRewardCountdownIntervalId) clearInterval(bossRewardCountdownIntervalId);
            bossRewardCountdownIntervalId = setInterval(() => { timeLeft--; bossRewardTimerDisplay.textContent = `关闭倒计时: ${timeLeft}s`; if (timeLeft <= 0) closeBossRewardModal(); }, 1000);
            if (bossRewardTimeoutId) clearTimeout(bossRewardTimeoutId); bossRewardTimeoutId = setTimeout(closeBossRewardModal, 6000);
        }

        function closeBossRewardModal() {
            playSound('buttonClick');
            bossRewardModalActive = false; bossRewardModal.style.display = 'none';
            if (bossRewardCountdownIntervalId) clearInterval(bossRewardCountdownIntervalId); if (bossRewardTimeoutId) clearTimeout(bossRewardTimeoutId);
            if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop);
        }

        function checkLevelUp() {
            if (!player || !gameRunning) return;
            const currentLevelXpNeeded = (player.level < XP_PER_LEVEL.length) ? XP_PER_LEVEL[player.level] : XP_PER_LEVEL[XP_PER_LEVEL.length - 1] + (player.level - (XP_PER_LEVEL.length - 1)) * 400;
            if (player.xp >= currentLevelXpNeeded) {
                playSound('levelUp');
                player.level++; player.xp -= currentLevelXpNeeded; presentSkillSelection();
            }
        }

        function presentSkillSelection() {
            if (skillSelectionActive || bossRewardModalActive || !player || !gameRunning) return;
            skillSelectionActive = true; skillOptionsContainer.innerHTML = '';
            const availableChoices = ALL_SKILLS.filter(skill => {
                const currentStacks = player.learnedSkills[skill.id] || 0;
                if (skill.maxStacks !== undefined && currentStacks >= skill.maxStacks) return false;
                if (skill.prerequisite && !(player.learnedSkills[skill.prerequisite] > 0)) return false;

                if (skill.id === 'xp_gain_boost' && player.xpGainMultiplier >= 2.0) return false;
                if (skill.id === 'slime_accelerate' && player.slimeSpeedMultiplier >= MAX_SLIME_SPEED_MULTIPLIER) return false;
                if (skill.id === 'energy_wave_cooldown_down' && player.energyWaveCooldown <= 10000) return false;

                return true;
            });

            availableChoices.sort((a, b) => {
                const categoryAIndex = SKILL_CATEGORY_ORDER.indexOf(a.category);
                const categoryBIndex = SKILL_CATEGORY_ORDER.indexOf(b.category);
                if (categoryAIndex !== categoryBIndex) return categoryAIndex - categoryBIndex;
                return a.name.localeCompare(b.name, 'zh-CN');
            });

            const chosenSkills = [];
            let tempAvailable = [...availableChoices];
            while (chosenSkills.length < 3 && tempAvailable.length > 0) {
                const randomIndex = Math.floor(Math.random() * tempAvailable.length);
                chosenSkills.push(tempAvailable.splice(randomIndex, 1)[0]);
            }

            if (chosenSkills.length === 0) {
                skillSelectionActive = false;
                if (gameRunning && animationFrameId === null) {
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
                return;
            }

            chosenSkills.forEach(skill => {
                const button = document.createElement('button');
                button.className = 'skill-option-btn';
                button.textContent = `${skill.name} - ${skill.description}`;
                button.onclick = () => selectSkill(skill);
                skillOptionsContainer.appendChild(button);
            });

            skillModal.style.display = 'block';
            let timeLeft = 6;
            skillTimerDisplay.textContent = `剩余时间: ${timeLeft}s`;
            if (skillSelectionCountdownIntervalId) clearInterval(skillSelectionCountdownIntervalId);
            skillSelectionCountdownIntervalId = setInterval(() => {
                timeLeft--;
                skillTimerDisplay.textContent = `剩余时间: ${timeLeft}s`;
                if (timeLeft <= 0) {
                    clearInterval(skillSelectionCountdownIntervalId);
                    const randomSkillIndex = Math.floor(Math.random() * chosenSkills.length);
                    selectSkill(chosenSkills[randomSkillIndex]);
                }
            }, 1000);
        }


        function selectSkill(skill) {
            if (!skillSelectionActive || !player) return;
            playSound('skillSelect');
            skill.apply(player); player.learnedSkills[skill.id] = (player.learnedSkills[skill.id] || 0) + 1;
            skillModal.style.display = 'none'; skillSelectionActive = false;
            if (skillSelectionCountdownIntervalId) clearInterval(skillSelectionCountdownIntervalId);
            updateUI(); if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop);
        }

        function toggleSkillBook() {
            playSound('buttonClick');
            skillBookOpen = !skillBookOpen;
            if (skillBookOpen) { renderSkillBook(); skillBookModal.style.display = 'block'; }
            else { skillBookModal.style.display = 'none'; if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop); }
        }

        function renderSkillBook() {
            if (!player) return; skillBookContent.innerHTML = '';
            const sortedSkills = [...ALL_SKILLS].sort((a, b) => { const categoryAIndex = SKILL_CATEGORY_ORDER.indexOf(a.category); const categoryBIndex = SKILL_CATEGORY_ORDER.indexOf(b.category); if (categoryAIndex !== categoryBIndex) return categoryAIndex - categoryBIndex; return a.name.localeCompare(b.name, 'zh-CN'); });
            sortedSkills.forEach(skill => { const level = player.learnedSkills[skill.id] || 0; const entryDiv = document.createElement('div'); entryDiv.className = 'skill-entry' + (level > 0 ? ' learned' : ''); let skillTitle = `<h4>${skill.name}`; if (level > 0) skillTitle += ` <span class="skill-level">(等级 ${level})</span>`; if (skill.maxStacks !== undefined) skillTitle += ` (最大 ${skill.maxStacks}级)`; skillTitle += `</h4>`; entryDiv.innerHTML = `${skillTitle}<p>${skill.description}</p>`; skillBookContent.appendChild(entryDiv); });
        }

        function gameOver() {
            playSound('gameOver');
            if (activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
                activeBossSpawnSound = null;
            }
            gameRunning = false; finalWaveDisplay.textContent = wave; finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'block';

        }

        function drawSingleBackground(bgImage, alpha = 1) {
            if (bgImage && bgImage.complete && bgImage.naturalHeight !== 0) {
                ctx.globalAlpha = alpha;
                const canvasAspect = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT;
                const imgAspect = bgImage.naturalWidth / bgImage.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                if (canvasAspect > imgAspect) {
                    drawWidth = BASE_CANVAS_WIDTH;
                    drawHeight = BASE_CANVAS_WIDTH / imgAspect;
                    drawX = 0;
                    drawY = (BASE_CANVAS_HEIGHT - drawHeight) / 2;
                } else {
                    drawHeight = BASE_CANVAS_HEIGHT;
                    drawWidth = BASE_CANVAS_HEIGHT * imgAspect;
                    drawY = 0;
                    drawX = (BASE_CANVAS_WIDTH - drawWidth) / 2;
                }
                ctx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
                ctx.globalAlpha = 1;
            } else if (alpha === 1) {
                ctx.fillStyle = '#333745';
                ctx.fillRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT);
            }
        }

        function drawGameBackground() {
            if (crossfadeProgress < 1 && oldBackgroundImage && backgroundImage && oldBackgroundImage !== backgroundImage) {
                drawSingleBackground(oldBackgroundImage, 1 - crossfadeProgress);
                drawSingleBackground(backgroundImage, crossfadeProgress);
            } else {
                drawSingleBackground(backgroundImage);
                if (oldBackgroundImage && crossfadeProgress >= 1) {
                    if (oldBackgroundImage.src) oldBackgroundImage.src = '';
                    oldBackgroundImage = null;
                }
            }
        }


        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastLoopTimestamp;
            lastLoopTimestamp = timestamp;

            if (!gameRunning && !skillBookOpen && !bossRewardModalActive) { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } return; }


            if (crossfadeProgress < 1 && oldBackgroundImage) {
                crossfadeProgress += (deltaTime / crossfadeDuration);
                crossfadeProgress = Math.min(1, crossfadeProgress);
                 if (crossfadeProgress >= 1 && oldBackgroundImage) {
                    if(oldBackgroundImage.src) oldBackgroundImage.src = '';
                    oldBackgroundImage = null;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);


            const scaleX = canvas.width / BASE_CANVAS_WIDTH;
            const scaleY = canvas.height / BASE_CANVAS_HEIGHT;
            const scale = Math.min(scaleX, scaleY);

            const renderWidth = BASE_CANVAS_WIDTH * scale;
            const renderHeight = BASE_CANVAS_HEIGHT * scale;

            const offsetX = (canvas.width - renderWidth) / 2;
            const offsetY = (canvas.height - renderHeight) / 2;

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            drawGameBackground();

            if (gameRunning && !skillSelectionActive && !skillBookOpen && !bossRewardModalActive) {
                updatePlayer(timestamp);
                updateSlimes(timestamp);
                updateEnergyWaves();
                updateWindBlades(timestamp);
                if (currentBoss && currentBoss.hp > 0) {
                    updateBoss(timestamp);
                    updateEnemies(bossSummons, timestamp);
                } else if (!currentBoss) {
                    updateEnemies(zombies, timestamp);
                }
                updateBullets();
            }

            drawPlayer();
            drawSlimes();
            drawEnergyWaves();
            drawWindBlades();
            if (currentBoss && currentBoss.hp > 0) {
                drawBoss();
                drawZombiesAndSummons();
            } else if (!currentBoss) {
                drawZombiesAndSummons();
            }
            drawBullets();

            ctx.restore();

            if (gameRunning && !skillSelectionActive && !skillBookOpen && !bossRewardModalActive) {
                 if ((!currentBoss || currentBoss.hp <= 0) && zombies.length === 0 && bossSummons.length === 0) {
                    advanceWave();
                }
            }

            if (gameRunning || skillBookOpen || bossRewardModalActive) animationFrameId = requestAnimationFrame(gameLoop);
            else { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }}
        }

        function initCollapsiblePanels() {
            const panelHeaders = document.querySelectorAll('.collapsible-panel-header');
            const panelStates = JSON.parse(localStorage.getItem('zombieSiegePanelStates')) || {};

            panelHeaders.forEach(header => {
                const panelId = header.dataset.panelId;
                const content = header.nextElementSibling;
                const btn = header.querySelector('.collapsible-panel-toggle-btn');

                if (!content || !btn) {
                    console.warn("Collapsible panel structure incorrect for:", header);
                    return;
                }


                let isInitiallyExpanded = true;
                if (panelId && typeof panelStates[panelId] === 'boolean') {
                    isInitiallyExpanded = panelStates[panelId];
                }

                if (!isInitiallyExpanded) {
                    content.classList.add('collapsed');
                    btn.textContent = '+';
                    btn.setAttribute('aria-expanded', 'false');
                    header.classList.add('collapsed-state');
                } else {
                    content.classList.remove('collapsed');
                    btn.textContent = '-';
                    btn.setAttribute('aria-expanded', 'true');
                    header.classList.remove('collapsed-state');
                }


                header.addEventListener('click', function(event) {
                    if (event.target === btn) return;
                    btn.click();
                });

                btn.addEventListener('click', function(event) {
                    event.stopPropagation();

                    if (typeof playSound === 'function' && soundEffectPaths.buttonClick) {
                         playSound('buttonClick');
                    }

                    content.classList.toggle('collapsed');
                    const isExpanded = !content.classList.contains('collapsed');
                    this.textContent = isExpanded ? '-' : '+';
                    this.setAttribute('aria-expanded', isExpanded);


                    if (panelId) {
                        panelStates[panelId] = isExpanded;
                        localStorage.setItem('zombieSiegePanelStates', JSON.stringify(panelStates));
                    }
                });
            });
        }

        function resizeCanvas() {
            const containerWidth = gameCanvasContainer.offsetWidth;


            const containerHeight = gameCanvasContainer.offsetHeight;


            canvas.width = containerWidth;
            canvas.height = containerHeight;



        }


        window.onload = () => {
            initializeSoundPlayers();

            toggleSoundBtn = document.createElement('button');
            toggleSoundBtn.onclick = () => { playSound('buttonClick'); toggleSound(); };
            const gameButtonsDiv = document.querySelector('.stats-right .game-buttons');
            if (gameButtonsDiv) {
                const bgBtn = document.getElementById('toggleBgBtn');
                if (bgBtn && bgBtn.nextSibling) {
                    gameButtonsDiv.insertBefore(toggleSoundBtn, bgBtn.nextSibling);
                } else if (bgBtn) {
                    gameButtonsDiv.appendChild(toggleSoundBtn);
                }
                 else {
                    gameButtonsDiv.appendChild(toggleSoundBtn);
                }
            }


            const savedAutoBg = localStorage.getItem('zombieSiegeAutoBg');
            if (savedAutoBg !== null) {
                autoChangeBackground = JSON.parse(savedAutoBg);
            }
            const bgBtnElement = document.getElementById('toggleBgBtn');
            if(bgBtnElement) {
                 bgBtnElement.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            }

            initCollapsiblePanels();
            if (windBladeStatsRow) windBladeStatsRow.style.display = '';

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            initGame();
        };
    </script>
</body>
</html>
