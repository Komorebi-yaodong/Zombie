<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Siege AI Edition - XP Cap & Enhanced Late Game Difficulty</title>
    <style>
        body {
            min-height: 100vh;
            margin: 0;
            padding: 10px 0;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #ecf0f1;
            overflow-y: auto;
            box-sizing: border-box;
        }

        #main-content-wrapper {
            width: 100%;
            max-width: 800px; /* Or your desired max game width */
            margin: 0 auto; /* Centers the wrapper */
        }

        .ui-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            /* width: 100%; Inherits from wrapper */
            /* max-width: 800px; Controlled by wrapper */
            margin-bottom: 5px; /* Spacing between UI and canvas container */
            padding: 10px 0; /* Internal padding for ui-container */
            font-size: 14px;
        }
         .ui-container::-webkit-scrollbar {
            width: 8px;
        }
        .ui-container::-webkit-scrollbar-track {
            background: rgba(44, 62, 80, 0.3);
            border-radius: 4px;
        }
        .ui-container::-webkit-scrollbar-thumb {
            background: #7f8c8d;
            border-radius: 4px;
        }
        .ui-container::-webkit-scrollbar-thumb:hover {
            background: #95a5a6;
        }

        #gameCanvasContainer {
            /* width: 100%; Inherits from wrapper */
            /* max-width: 800px; Controlled by wrapper */
            /* margin: 0 auto; No longer needed for horizontal centering, wrapper does it */
            position: relative;
            padding-top: 75%;
            border: 1px solid #7f8c8d;
            box-sizing: border-box;
            background-color: #333745;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .stats-left, .stats-middle, .stats-right {
            background-color: rgba(44, 62, 80, 0.8);
            border-radius: 5px;
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
        }
        .stats-left { min-width: 320px; flex-shrink: 0; }
        .stats-middle { flex-grow: 1; text-align: left; margin: 0 10px;}
        .stats-right { text-align: right; min-width: 160px; flex-shrink: 0; }

        .collapsible-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(127, 140, 141, 0.3);
        }
        .collapsible-panel-header.collapsed-state {
            border-bottom: none;
        }
        .collapsible-panel-title {
            font-weight: bold;
            color: #ecf0f1;
        }
        .collapsible-panel-toggle-btn {
            background: none;
            border: 1px solid #7f8c8d;
            color: #ecf0f1;
            padding: 1px 7px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            line-height: 1.2;
            margin-left: 10px;
        }
        .collapsible-panel-toggle-btn:hover {
            background-color: rgba(127, 140, 141, 0.2);
        }
        .collapsible-panel-content {
            padding: 10px;
        }
        .collapsible-panel-content.collapsed {
            display: none;
            padding: 0;
        }

        .stats-left p, .stats-middle p, .stats-right p { margin: 4px 0; }
        .collapsible-panel-content > p:first-child,
        .collapsible-panel-content > .progress-bar-container:first-child,
        .collapsible-panel-content > .stats-title:first-child {
             margin-top: 0;
        }
         .collapsible-panel-content > *:first-child {
            margin-top: 2px;
        }
        .collapsible-panel-content > *:last-child {
            margin-bottom: 0;
        }


        .progress-bar-container { width: 150px; height: 10px; background-color: #7f8c8d; border-radius: 5px; overflow: hidden; margin-top: 3px; }
        .progress-bar { height: 100%; background-color: #2ecc71; transition: width 0.2s ease-out; }
        .xp-bar { background-color: #3498db; }
        .stats-middle .stats-title { text-align: center; font-weight: bold; margin-bottom: 8px !important; }
        .stats-middle .zombie-type-label { font-weight: bold; color: #e67e22; display: block; margin-top: 6px; margin-bottom: 2px;}
        .stats-middle .stats-note { font-size: 0.8em; text-align: center; margin-top: 8px !important; color: #bdc3c7; }
        .modal { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: rgba(52, 73, 94, 0.97); padding: 20px; border-radius: 10px; border: 2px solid #95a5a6; z-index: 1000; text-align: center; box-shadow: 0 0 20px rgba(0,0,0,0.5); max-height: 80vh; overflow-y: auto; }
        .modal h3 { margin-top: 0; color: #e67e22; }
        .modal button.skill-option-btn, .modal button.close-btn { background-color: #2980b9; color: white; border: none; padding: 10px 15px; margin: 10px 5px; border-radius: 5px; cursor: pointer; font-size: 14px; transition: background-color 0.3s; }
        .modal button.skill-option-btn:hover { background-color: #3498db; }
        .modal button.close-btn { background-color: #c0392b; margin-top: 20px; }
        .modal button.close-btn:hover { background-color: #e74c3c; }
        #skillModal { width: 500px; }
        #skillTimer { margin-top: 15px; font-size: 12px; color: #bdc3c7; }
        #skillBookModal { width: 600px; text-align: left; }
        #skillBookModal .skill-entry { background-color: rgba(44, 62, 80, 0.7); padding: 10px; margin-bottom: 8px; border-radius: 4px; border-left: 3px solid #7f8c8d; }
        #skillBookModal .skill-entry.learned { border-left-color: #2ecc71; }
        #skillBookModal .skill-entry h4 { margin: 0 0 5px 0; color: #ecf0f1; }
        #skillBookModal .skill-entry p { margin: 0; font-size: 0.9em; color: #bdc3c7; }
        #skillBookModal .skill-level { font-weight: bold; color: #f1c40f; }
        #gameOverScreen, #startGamePrompt { display: none; position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); background-color: rgba(44, 62, 80, 0.95); padding: 30px; border-radius: 10px; text-align: center; z-index: 1001; border: 1px solid #7f8c8d; }
        #gameOverScreen h2, #startGamePrompt h2 { margin-top: 0; color: white; }
        #gameOverScreen button, #startGamePrompt button { background-color: #2ecc71; color: white; border: none; padding: 10px 20px; margin: 10px 5px; border-radius: 5px; cursor: pointer; font-size: 16px; }
        #startGamePrompt button.new-game-btn { background-color: #3498db; }

        .game-buttons {
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }
        .game-buttons button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 3px 0;
            border-radius: 3px;
            cursor: pointer;
            min-width: 100px;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
            font-size: 13px;
        }

        #bossRewardModal { width: 400px; }
        #bossRewardModal ul { list-style-type: none; padding: 0; }
        #bossRewardModal li { background-color: rgba(44, 62, 80, 0.6); padding: 8px; margin: 5px 0; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="startGamePrompt">
        <h2>游戏存档</h2>
        <p>发现之前的游戏存档。</p>
        <button onclick="continueGame()">继续游戏</button>
        <button class="new-game-btn" onclick="startNewGame()">开始新游戏</button>
    </div>

    <div id="main-content-wrapper">
        <div class="ui-container">
            <div class="stats-left">
                <div class="collapsible-panel-header" data-panel-id="statsLeftPanel">
                    <span class="collapsible-panel-title">玩家状态</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p>生命值: <span id="playerHp">100</span> / <span id="playerMaxHp">100</span></p>
                    <div class="progress-bar-container"><div class="progress-bar" id="playerHpBar" style="width: 100%;"></div></div>
                    <p>经验值: <span id="playerXp">0</span> / <span id="xpToLevelUp">100</span> (等级 <span id="playerLevel">1</span>)</p>
                    <div class="progress-bar-container"><div class="progress-bar xp-bar" id="playerXpBar" style="width: 0%;"></div></div>
                    <p>主子弹: 伤害 <span id="bulletDamageDisplay">10.0</span> | 弹道 <span id="projectileCountDisplay">1</span> | 每道 <span id="bulletsPerShotDisplay">1</span> | 穿透 <span id="bulletPierceCountDisplay">0</span></p>
                    <p>史莱姆: 数量 <span id="slimeCountDisplay">0</span> | 伤害 <span id="slimeDamageDisplay">20.0</span> | 速度 <span id="slimeSpeedMultiplierDisplay">100%</span></p>
                    <p>能量波: <span id="hasEnergyWaveDisplay">否</span> | 伤害 <span id="energyWaveDamageDisplay">20</span> | CD <span id="energyWaveCooldownDisplay">30</span>s</p>
                    <p>每5秒生命回复: <span id="hpRegenPer5SecDisplay">0</span></p>
                    <p>经验获取倍率: <span id="xpGainMultiplierDisplay">100%</span></p>
                </div>
            </div>
            <div class="stats-middle">
                <div class="collapsible-panel-header" data-panel-id="statsMiddlePanel">
                    <span class="collapsible-panel-title">敌人属性</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p class="stats-title" id="middleStatsTitle">当前波数僵尸属性</p>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">普通型:</span>
                        <p>生命 <span id="zombieNormalHp">N/A</span> | 伤害 <span id="zombieNormalDamage">N/A</span> | 速度 <span id="zombieNormalSpeed">N/A</span></p>
                    </div>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">快速型:</span>
                        <p>生命 <span id="zombieFastHp">N/A</span> | 伤害 <span id="zombieFastDamage">N/A</span> | 速度 <span id="zombieFastSpeed">N/A</span></p>
                    </div>
                    <div class="zombie-type-stats-container">
                        <span class="zombie-type-label">坦克型:</span>
                        <p>生命 <span id="zombieTankHp">N/A</span> | 伤害 <span id="zombieTankDamage">N/A</span> | 速度 <span id="zombieTankSpeed">N/A</span></p>
                    </div>
                    <div id="bossStatsDisplay" style="display:none;">
                         <p>生命: <span id="bossHpDisplay">N/A</span> / <span id="bossMaxHpDisplay">N/A</span></p>
                         <p>速度: <span id="bossSpeedDisplay">N/A</span></p>
                    </div>
                    <p class="stats-note" id="zombieStatsNote">(属性随波数提升)</p>
                </div>
            </div>
            <div class="stats-right">
                <div class="collapsible-panel-header" data-panel-id="statsRightPanel">
                    <span class="collapsible-panel-title">游戏信息与控制</span>
                    <button class="collapsible-panel-toggle-btn" aria-expanded="true">-</button>
                </div>
                <div class="collapsible-panel-content">
                    <p>波数: <span id="waveCount">1</span></p>
                    <p>分数: <span id="scoreCount">0</span></p>
                    <div class="game-buttons">
                        <button onclick="toggleSkillBook()">查看技能</button>
                        <button onclick="saveGame()">保存游戏</button>
                        <button id="toggleBgBtn" onclick="toggleAutoChangeBackground()">更换背景: 开</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="gameCanvasContainer">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>


    <div id="skillModal" class="modal"><h3>选择一个技能！</h3><div id="skillOptions"></div><p id="skillTimer">剩余时间: 6s</p></div>
    <div id="skillBookModal" class="modal"><h3>技能书</h3><div id="skillBookContent"></div><button class="close-btn" onclick="toggleSkillBook()">关闭</button></div>
    <div id="gameOverScreen"><h2>游戏结束!</h2><p>最终波数: <span id="finalWave"></span></p><p>最终分数: <span id="finalScore"></span></p><button onclick="startNewGame(true)">重新开始</button></div>
    <div id="bossRewardModal" class="modal">
        <h3>Boss Defeated! Skills Acquired:</h3>
        <div id="bossRewardSkillList"></div>
        <p id="bossRewardTimer">Closing in: 6s</p>
        <button class="close-btn" onclick="closeBossRewardModal()">关闭</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const gameCanvasContainer = document.getElementById('gameCanvasContainer');

        const BASE_CANVAS_WIDTH = 800;
        const BASE_CANVAS_HEIGHT = 600;

        const playerHpDisplay = document.getElementById('playerHp'); const playerMaxHpDisplay = document.getElementById('playerMaxHp'); const playerHpBar = document.getElementById('playerHpBar');
        const playerXpDisplay = document.getElementById('playerXp'); const xpToLevelUpDisplay = document.getElementById('xpToLevelUp'); const playerLevelDisplay = document.getElementById('playerLevel'); const playerXpBar = document.getElementById('playerXpBar');
        const bulletDamageDisplay = document.getElementById('bulletDamageDisplay'); const projectileCountDisplay = document.getElementById('projectileCountDisplay'); const bulletsPerShotDisplay = document.getElementById('bulletsPerShotDisplay'); const bulletPierceCountDisplay = document.getElementById('bulletPierceCountDisplay');
        const waveCountDisplay = document.getElementById('waveCount'); const scoreCountDisplay = document.getElementById('scoreCount');
        const skillModal = document.getElementById('skillModal'); const skillOptionsContainer = document.getElementById('skillOptions'); const skillTimerDisplay = document.getElementById('skillTimer');
        const skillBookModal = document.getElementById('skillBookModal'); const skillBookContent = document.getElementById('skillBookContent');
        const gameOverScreen = document.getElementById('gameOverScreen'); const finalWaveDisplay = document.getElementById('finalWave'); const finalScoreDisplay = document.getElementById('finalScore');
        const startGamePrompt = document.getElementById('startGamePrompt');
        const hpRegenPer5SecDisplay = document.getElementById('hpRegenPer5SecDisplay'); const xpGainMultiplierDisplay = document.getElementById('xpGainMultiplierDisplay');
        const slimeCountDisplay = document.getElementById('slimeCountDisplay'); const slimeDamageDisplay = document.getElementById('slimeDamageDisplay'); const slimeSpeedMultiplierDisplay = document.getElementById('slimeSpeedMultiplierDisplay');
        const hasEnergyWaveDisplay = document.getElementById('hasEnergyWaveDisplay'); const energyWaveDamageDisplay = document.getElementById('energyWaveDamageDisplay'); const energyWaveCooldownDisplay = document.getElementById('energyWaveCooldownDisplay');

        const zombieNormalHpDisplay = document.getElementById('zombieNormalHp'); const zombieNormalDamageDisplay = document.getElementById('zombieNormalDamage'); const zombieNormalSpeedDisplay = document.getElementById('zombieNormalSpeed');
        const zombieFastHpDisplay = document.getElementById('zombieFastHp'); const zombieFastDamageDisplay = document.getElementById('zombieFastDamage'); const zombieFastSpeedDisplay = document.getElementById('zombieFastSpeed');
        const zombieTankHpDisplay = document.getElementById('zombieTankHp'); const zombieTankDamageDisplay = document.getElementById('zombieTankDamage'); const zombieTankSpeedDisplay = document.getElementById('zombieTankSpeed');

        const middleStatsTitle = document.getElementById('middleStatsTitle');
        const zombieTypeStatContainers = document.querySelectorAll('.zombie-type-stats-container');
        const bossStatsDisplay = document.getElementById('bossStatsDisplay');
        const bossHpDisplay = document.getElementById('bossHpDisplay');
        const bossMaxHpDisplay = document.getElementById('bossMaxHpDisplay');
        const bossSpeedDisplay = document.getElementById('bossSpeedDisplay');
        const zombieStatsNote = document.getElementById('zombieStatsNote');

        const bossRewardModal = document.getElementById('bossRewardModal');
        const bossRewardSkillList = document.getElementById('bossRewardSkillList');
        const bossRewardTimerDisplay = document.getElementById('bossRewardTimer');
        const toggleBgBtn = document.getElementById('toggleBgBtn');
        let toggleSoundBtn;


        let player, zombies, bullets, energyWaves, currentBoss; let wave, score, gameRunning, skillSelectionActive, skillBookOpen, bossRewardModalActive;
        let skillSelectionTimeoutId, skillSelectionCountdownIntervalId; let animationFrameId = null;
        let bossRewardTimeoutId, bossRewardCountdownIntervalId;

        let autoChangeBackground = true;
        let nextBackgroundImage = null;
        let oldBackgroundImage = null;
        let crossfadeProgress = 1;
        const crossfadeDuration = 1000;
        let lastLoopTimestamp = 0;

        let isFetchingNextBackground = false;
        let currentBackgroundSeed = Math.floor(Math.random() * 1000000);
        const REMOTE_BACKGROUND_BASE_URL = 'https://image.pollinations.ai/prompt/Gritty%202D%20isometric%20game%20art%2C%20top-down%20view%20of%20a%20desolate%2C%20ruined%20city%20street%2C%20abandoned%20cars%20scattered%20among%20rubble%20and%20cracked%20asphalt%2C%20muted%20color%20palette%2C%20strategic%20game%20map%20feel?width=1216&height=832&seed={SEED}&model=flux&enhance=true&nologo=true&safe=false';


        const INITIAL_BULLET_DAMAGE = 10; const PLAYER_SHOOT_COOLDOWN = 800; const INTER_BULLET_DELAY = 80;
        let lastShotTime = 0; let timeOfLastBurstBullet = 0;
        const XP_PER_LEVEL = [0, 75, 175, 300, 450, 625, 825, 1050, 1300, 1575, 1875, 2200, 2550, 2925, 3325, 3750];

        const ZOMBIE_TYPES = {
            normal: { hp: 25, speed: 0.28, damage: 7, xp: 10, color: '#27ae60', size: 15 },
            fast:   { hp: 15, speed: 0.5, damage: 3, xp: 15, color: '#f1c40f', size: 12 },
            tank:   { hp: 50, speed: 0.15, damage: 10, xp: 30, color: '#c0392b', size: 20 }
        };
        const BOSS_STATS = {
            id: "the_boss_id",
            hp: 1000,
            damage: 999999,
            xp: 500,
            color: '#8e44ad',
            size: 60,
            speed: 0.5,
            pathShrinkAmount: 50,
            initialPathDimensionFactor: 0.9
        };

        let nextUniqueId = 0; const MAX_SLIME_SPEED = 1.5;
        const ALL_SKILLS = [
            { id: 'hp_boost', name: '生命强化', description: '最大生命值增加50, 并回复50点生命', category: 'player', apply: (p) => { p.maxHp += 50; p.hp = Math.min(p.hp + 50, p.maxHp); } },
            { id: 'life_heal_over_time', name: '生命治愈', description: '每5秒回复1点生命', category: 'player', apply: (p) => { p.hpRegenPer5Sec += 1; } },
            { id: 'xp_gain_boost', name: '经验加速', description: '获取经验值增加20% (最高200%)', category: 'player', apply: (p) => { p.xpGainMultiplier = Math.min(p.xpGainMultiplier + 0.20, 2.0); } },
            { id: 'damage_boost_flat', name: '主子弹强化 (固定)', description: '主子弹固定伤害增加5点', category: 'bullet', apply: (p) => { p.bulletFlatDamageBonus += 5; } },
            { id: 'damage_boost_percent', name: '主子弹强化 (百分比)', description: '当前主子弹伤害增加60%', category: 'bullet', apply: (p) => { p.bulletDamageMultiplier += 0.6; } },
            { id: 'projectile_increase', name: '弹道增加', description: '增加一个弹道，但主子弹伤害减少15%', category: 'bullet', apply: (p) => { p.projectileCount++; p.bulletDamageMultiplier -= 0.15; } },
            { id: 'multishot', name: '子弹连发', description: '每个弹道，每次射击增加一个主子弹，但主子弹伤害减少15%', category: 'bullet', apply: (p) => { p.bulletsPerShot++; p.bulletDamageMultiplier -= 0.15; } },
            { id: 'bullet_pierce', name: '子弹穿透', description: '主子弹可以穿透一个敌人', category: 'bullet', apply: (p) => { p.bulletPierceCount += 1; } },
            { id: 'summon_slime', name: '召唤史莱姆', description: '召唤一个史莱姆，触碰到的僵尸将每秒受到20伤害', category: 'slime', maxStacks: 1,
                apply: function(p) {
                    let newSlimeX, newSlimeY; let attempts = 0; const MAX_ATTEMPTS = 20; const slimeSize = 10; let positionFound = false;
                    while (attempts < MAX_ATTEMPTS && !positionFound) {
                        const offsetX = Math.random() * 40 - 20; const offsetY = Math.random() * 40 - 20;
                        newSlimeX = p.x + offsetX; newSlimeY = p.y + offsetY; positionFound = true;
                        for (const existingSlime of p.slimes) {
                            if (Math.hypot(newSlimeX - existingSlime.x, newSlimeY - existingSlime.y) < (slimeSize + existingSlime.size) / 2 + 3) {
                                positionFound = false; break;
                            }
                        } attempts++;
                    }
                    if (!positionFound) { newSlimeX = p.x; newSlimeY = p.y; }
                    p.slimes.push({ id: nextUniqueId++, x: newSlimeX, y: newSlimeY, size: slimeSize, color: 'rgba(50, 200, 50, 0.6)', speed: 0.4, targetEnemyId: null, targetIsBoss: false, lastDamageApplicationTimes: {} });
                }
            },
            { id: 'slime_surge', name: '史莱姆涌动', description: '新召唤一个史莱姆，但是史莱姆伤害减少20%', category: 'slime', prerequisite: 'summon_slime',
                apply: function(p) {
                    let newSlimeX, newSlimeY; let attempts = 0; const MAX_ATTEMPTS = 20; const slimeSize = 10; let positionFound = false;
                     while (attempts < MAX_ATTEMPTS && !positionFound) {
                        const offsetX = Math.random() * 40 - 20; const offsetY = Math.random() * 40 - 20;
                        newSlimeX = p.x + offsetX; newSlimeY = p.y + offsetY; positionFound = true;
                        for (const existingSlime of p.slimes) {
                             if (Math.hypot(newSlimeX - existingSlime.x, newSlimeY - existingSlime.y) < (slimeSize + existingSlime.size) / 2 + 3) {
                                positionFound = false; break;
                            }
                        } attempts++;
                    }
                    if (!positionFound) { newSlimeX = p.x; newSlimeY = p.y; }
                    p.slimes.push({ id: nextUniqueId++, x: newSlimeX, y: newSlimeY, size: slimeSize, color: 'rgba(50, 200, 50, 0.6)', speed: 0.4, targetEnemyId: null, targetIsBoss: false, lastDamageApplicationTimes: {} });
                    p.slimeDamagePercentMultiplier -= 0.20;
                }
            },
            { id: 'slime_devour', name: '史莱姆吞噬', description: '史莱姆伤害增加60%', category: 'slime', prerequisite: 'summon_slime', apply: (p) => { p.slimeDamagePercentMultiplier += 0.60; } },
            { id: 'slime_accelerate', name: '史莱姆加速', description: '史莱姆移动速度增加25% (有上限)', category: 'slime', prerequisite: 'summon_slime', apply: (p) => { p.slimeSpeedMultiplier = Math.min(p.slimeSpeedMultiplier + 0.25, MAX_SLIME_SPEED / 0.4); } },
            { id: 'energy_wave_aoe', name: '能量波动', description: '每30秒发射环形能量波，造成12伤害', category: 'energy_wave', maxStacks: 1, apply: (p) => { p.hasEnergyWave = true; } },
            { id: 'energy_wave_damage_up', name: '能量增强', description: '增加100%能量波的伤害', category: 'energy_wave', prerequisite: 'energy_wave_aoe', apply: (p) => { p.energyWaveDamageMultiplier += 1.00; } },
            { id: 'energy_wave_cooldown_down', name: '能量聚集', description: '减少能量波动的冷却1秒 (最低10秒)', category: 'energy_wave', prerequisite: 'energy_wave_aoe', apply: (p) => { p.energyWaveCooldown = Math.max(10000, p.energyWaveCooldown - 1000); } }
        ];
        const SKILL_CATEGORY_ORDER = ['player', 'bullet', 'slime', 'energy_wave'];

        let soundEnabled = true;
        const soundEffectPaths = {
            shoot: 'sounds/shoot.mp3',
            zombieDie: 'sounds/zombie_die.mp3',
            playerHurt: 'sounds/player_hurt.mp3',
            levelUp: 'sounds/level_up.mp3',
            gameOver: 'sounds/game_over.mp3',
            waveStart: 'sounds/wave_start.mp3',
            bossSpawn: 'sounds/boss_spawn.mp3',
            bossDie: 'sounds/boss_die.mp3',
            skillSelect: 'sounds/skill_select.mp3',
            energyWaveFire: 'sounds/energy_wave_fire.mp3',
            buttonClick: 'sounds/button_click.mp3',
            skillAcquired: 'sounds/skill_acquired.mp3'
        };
        const soundEffectVolumes = {
            shoot: 0.15,
            zombieDie: 0.2,
            playerHurt: 0.3,
            levelUp: 0.5,
            gameOver: 0.6,
            waveStart: 0.3,
            bossSpawn: 0.3,
            bossDie: 0.3,
            skillSelect: 0.3,
            energyWaveFire: 0.3,
            slimeAttack: 0.3,
            buttonClick: 0.4,
            skillAcquired: 0.5
        };
        let activeBossSpawnSound = null;

        function playSound(soundKey, options = {}) {
            if (!soundEnabled || !soundEffectPaths[soundKey]) return;

            const audio = new Audio(soundEffectPaths[soundKey]);
            audio.volume = soundEffectVolumes[soundKey] !== undefined ? soundEffectVolumes[soundKey] : 0.3;

            if (soundKey === 'bossSpawn') {
                if (activeBossSpawnSound) {
                    fadeOutAndStop(activeBossSpawnSound);
                }
                activeBossSpawnSound = audio;
                audio.play().catch(e => {});
                if (options.fadeOutDuration) {
                    setTimeout(() => {
                        if (activeBossSpawnSound === audio) {
                           fadeOutAndStop(audio, options.fadeOutDuration);
                           activeBossSpawnSound = null;
                        }
                    }, (audio.duration * 1000 || 5000) - options.fadeOutDuration);
                }
            } else {
                audio.play().catch(e => {});
            }
        }

        function fadeOutAndStop(audioInstance, duration = 2000) {
            if (!audioInstance || audioInstance.volume === 0) return;
            let currentVolume = audioInstance.volume;
            const steps = 50;
            const stepTime = duration / steps;
            const volumeDecrement = currentVolume / steps;

            let fadeInterval = setInterval(() => {
                currentVolume -= volumeDecrement;
                if (currentVolume <= 0) {
                    audioInstance.volume = 0;
                    audioInstance.pause();
                    audioInstance.currentTime = 0;
                    clearInterval(fadeInterval);
                } else {
                    audioInstance.volume = currentVolume;
                }
            }, stepTime);
        }


        function toggleSound() {
            soundEnabled = !soundEnabled;
            toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;
            localStorage.setItem('zombieSiegeSoundEnabled', soundEnabled);
            if (!soundEnabled && activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
                activeBossSpawnSound = null;
            }
        }


        let localBackgroundImage = new Image();
        let localBackgroundImageProcessed = false;
        localBackgroundImage.onload = function() {
            localBackgroundImageProcessed = true;
            if (!backgroundImageProcessed) {
                backgroundImage = localBackgroundImage;
                backgroundImageProcessed = true;
            }
            startGameManager();
        };
        localBackgroundImage.onerror = function() {
            localBackgroundImageProcessed = true;
            if (!backgroundImageProcessed) {
                backgroundImageProcessed = true;
            }
            startGameManager();
        };
        localBackgroundImage.src = './background.jpg';

        let backgroundImage = localBackgroundImage;
        let backgroundImageProcessed = false;


        function fetchNextBackgroundImage() {
            if (!autoChangeBackground || isFetchingNextBackground) {
                return;
            }
            isFetchingNextBackground = true;
            currentBackgroundSeed = Math.floor(Math.random() * 1000000);
            const url = REMOTE_BACKGROUND_BASE_URL.replace('{SEED}', currentBackgroundSeed);

            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = function() {
                nextBackgroundImage = img;
                isFetchingNextBackground = false;
            };
            img.onerror = function() {
                isFetchingNextBackground = false;
                setTimeout(fetchNextBackgroundImage, 3000);
            };
            img.src = url;
        }

        function toggleAutoChangeBackground() {
            playSound('buttonClick');
            autoChangeBackground = !autoChangeBackground;
            toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            localStorage.setItem('zombieSiegeAutoBg', JSON.stringify(autoChangeBackground));
            if (autoChangeBackground && !nextBackgroundImage && !isFetchingNextBackground) {
                fetchNextBackgroundImage();
            }
        }

        function startGameManager() {
            if (gameRunning && (localBackgroundImageProcessed || backgroundImageProcessed) && animationFrameId === null) {
                if(!backgroundImageProcessed && localBackgroundImageProcessed) {
                    backgroundImage = localBackgroundImage;
                    backgroundImageProcessed = true;
                }
                lastLoopTimestamp = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function initializeNewGameVariables() {
            const now = performance.now();
            player = {
                x: BASE_CANVAS_WIDTH / 2, y: BASE_CANVAS_HEIGHT / 2, size: 20, color: '#3498db',
                hp: 100, maxHp: 100, xp: 0, level: 1,
                initialBulletDamage: INITIAL_BULLET_DAMAGE, bulletFlatDamageBonus: 0, bulletDamageMultiplier: 0,
                projectileCount: 1, bulletsPerShot: 1, shootCooldown: PLAYER_SHOOT_COOLDOWN,
                xpGainMultiplier: 1, learnedSkills: {}, currentBulletInBurst: 0,
                hpRegenPer5Sec: 0, lastHpRegenTime: now,
                bulletPierceCount: 0,
                slimes: [], slimeBaseDamage: 20, slimeDamagePercentMultiplier: 0, slimeSpeedMultiplier: 1,
                hasEnergyWave: false, energyWaveBaseDamage: 12,
                energyWaveDamageMultiplier: 0, energyWaveCooldown: 30000,
                lastEnergyWaveTime: now - 30000 + Math.min(5000, 30000)
            };
            zombies = []; bullets = []; energyWaves = []; currentBoss = null; wave = 0; score = 0; nextUniqueId = 0;
            lastShotTime = now - player.shootCooldown - 200;
            timeOfLastBurstBullet = now - INTER_BULLET_DELAY - 200;
            player.currentBulletInBurst = 0;
            oldBackgroundImage = null;
            crossfadeProgress = 1;
            if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) {
                fetchNextBackgroundImage();
            }
        }

        function initGame(isNewGame = false) {
            gameOverScreen.style.display = 'none'; skillModal.style.display = 'none'; skillBookModal.style.display = 'none'; bossRewardModal.style.display = 'none';

            const savedAutoBg = localStorage.getItem('zombieSiegeAutoBg');
            if (savedAutoBg !== null) {
                autoChangeBackground = JSON.parse(savedAutoBg);
            }
            if (toggleBgBtn) toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;


            if (!toggleSoundBtn) {
                 toggleSoundBtn = document.createElement('button');
                 const gameButtonsDiv = document.querySelector('.stats-right .game-buttons');
                 if (gameButtonsDiv) { gameButtonsDiv.appendChild(toggleSoundBtn); }
            }
            toggleSoundBtn.onclick = ()=>{playSound('buttonClick'); toggleSound();};
            const savedSoundEnabled = localStorage.getItem('zombieSiegeSoundEnabled');
            if (savedSoundEnabled !== null) {
                soundEnabled = JSON.parse(savedSoundEnabled);
            }
            toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;


            if (!isNewGame && localStorage.getItem('zombieSiegeSaveData')) { startGamePrompt.style.display = 'block'; gameRunning = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } return; }
            startGamePrompt.style.display = 'none';
            initializeNewGameVariables();
            gameRunning = true; skillSelectionActive = false; skillBookOpen = false; bossRewardModalActive = false;
            advanceWave(); updateUI(); startGameManager();
        }

        function startNewGame(fromGameOver = false) {
            playSound('buttonClick');
            if (fromGameOver) gameOverScreen.style.display = 'none'; startGamePrompt.style.display = 'none';
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            initGame(true);
        }

        function continueGame() {
            playSound('buttonClick');
            startGamePrompt.style.display = 'none'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            const loaded = loadGame();
            if (loaded) {
                if (player.hp <= 0) { updateUI(); gameOver(); return; }
                gameRunning = true; skillSelectionActive = false; skillBookOpen = false; bossRewardModalActive = false;
                if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) { fetchNextBackgroundImage(); }
                updateUI(); startGameManager();
            }
            else { alert("存档加载失败，开始新游戏。"); startNewGame(); }
        }

        function saveGame() {
            playSound('buttonClick');
            if (!player) { alert("游戏尚未开始，无法保存。"); return; }
            player.xpGainMultiplier = Math.min(player.xpGainMultiplier, 2.0);
            const saveData = { player: JSON.parse(JSON.stringify(player)), zombies: JSON.parse(JSON.stringify(zombies)), bullets: bullets.map(bullet => ({ ...bullet, hitTargets: bullet.hitTargets ? Array.from(bullet.hitTargets) : [] })), energyWaves: energyWaves.map(ew => ({ ...ew, hitZombies: Array.from(ew.hitZombies) })), currentBoss: currentBoss ? JSON.parse(JSON.stringify(currentBoss)) : null, wave, score, nextUniqueId, lastShotTime, timeOfLastBurstBullet };
            try {
                localStorage.setItem('zombieSiegeSaveData', JSON.stringify(saveData));
                localStorage.setItem('zombieSiegeAutoBg', JSON.stringify(autoChangeBackground));
                localStorage.setItem('zombieSiegeSoundEnabled', soundEnabled);
                alert('游戏已保存!');
            } catch (e) { alert('保存游戏失败，可能是存储已满。'); }
        }

        function loadGame() {
            const saveDataString = localStorage.getItem('zombieSiegeSaveData');
            const autoBgString = localStorage.getItem('zombieSiegeAutoBg');
            if (autoBgString !== null) {
                autoChangeBackground = JSON.parse(autoBgString);
                if(toggleBgBtn) toggleBgBtn.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            }
            const soundEnabledString = localStorage.getItem('zombieSiegeSoundEnabled');
             if (soundEnabledString !== null) {
                soundEnabled = JSON.parse(soundEnabledString);
                if (toggleSoundBtn) toggleSoundBtn.textContent = `声音: ${soundEnabled ? '开' : '关'}`;
            }


            if (!saveDataString) return false;
            try {
                const saveData = JSON.parse(saveDataString);
                player = saveData.player;
                zombies = saveData.zombies;
                bullets = saveData.bullets.map(bulletData => ({ ...bulletData, hitTargets: new Set(bulletData.hitTargets || []) }));
                energyWaves = saveData.energyWaves.map(ew => ({ ...ew, hitZombies: new Set(ew.hitZombies) }));
                currentBoss = saveData.currentBoss || null;
                wave = saveData.wave;
                score = saveData.score;
                nextUniqueId = saveData.nextUniqueId;

                const currentLoadTime = performance.now();

                player.initialBulletDamage = typeof player.initialBulletDamage === 'number' ? player.initialBulletDamage : INITIAL_BULLET_DAMAGE;
                player.bulletFlatDamageBonus = typeof player.bulletFlatDamageBonus === 'number' ? player.bulletFlatDamageBonus : 0;
                player.bulletDamageMultiplier = typeof player.bulletDamageMultiplier === 'number' ? player.bulletDamageMultiplier : 0;
                player.projectileCount = typeof player.projectileCount === 'number' ? player.projectileCount : 1;
                player.bulletsPerShot = typeof player.bulletsPerShot === 'number' ? player.bulletsPerShot : 1;
                player.shootCooldown = typeof player.shootCooldown === 'number' ? player.shootCooldown : PLAYER_SHOOT_COOLDOWN;
                player.xpGainMultiplier = Math.min(player.xpGainMultiplier || 1, 2.0);
                player.learnedSkills = player.learnedSkills || {};
                player.currentBulletInBurst = 0;
                player.hpRegenPer5Sec = typeof player.hpRegenPer5Sec === 'number' ? player.hpRegenPer5Sec : 0;
                player.bulletPierceCount = typeof player.bulletPierceCount === 'number' ? player.bulletPierceCount : 0;
                player.slimes = player.slimes || [];
                player.slimeBaseDamage = typeof player.slimeBaseDamage === 'number' ? player.slimeBaseDamage : 20;
                player.slimeDamagePercentMultiplier = typeof player.slimeDamagePercentMultiplier === 'number' ? player.slimeDamagePercentMultiplier : 0;
                player.slimeSpeedMultiplier = typeof player.slimeSpeedMultiplier === 'number' ? player.slimeSpeedMultiplier : 1;
                player.hasEnergyWave = typeof player.hasEnergyWave === 'boolean' ? player.hasEnergyWave : false;
                player.energyWaveBaseDamage = typeof player.energyWaveBaseDamage === 'number' ? player.energyWaveBaseDamage : 12;
                player.energyWaveDamageMultiplier = typeof player.energyWaveDamageMultiplier === 'number' ? player.energyWaveDamageMultiplier : 0;
                player.energyWaveCooldown = typeof player.energyWaveCooldown === 'number' ? player.energyWaveCooldown : 30000;

                player.lastHpRegenTime = currentLoadTime;
                const energyWaveReadyDelay = Math.min(5000, player.energyWaveCooldown);
                player.lastEnergyWaveTime = currentLoadTime - player.energyWaveCooldown + energyWaveReadyDelay;

                lastShotTime = currentLoadTime - (player.shootCooldown || PLAYER_SHOOT_COOLDOWN) - 200;
                timeOfLastBurstBullet = currentLoadTime - INTER_BULLET_DELAY - 200;
                player.currentBulletInBurst = 0;

                if (currentBoss) {
                    currentBoss.speed = currentBoss.speed || BOSS_STATS.speed;
                    currentBoss.pathTargetX = currentBoss.pathTargetX || 0;
                    currentBoss.pathTargetY = currentBoss.pathTargetY || 0;
                    currentBoss.pathSegment = currentBoss.pathSegment || 0;
                    currentBoss.currentPathDimension = currentBoss.currentPathDimension || (Math.min(BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT) * BOSS_STATS.initialPathDimensionFactor);
                    currentBoss.spiralCenterX = currentBoss.spiralCenterX || player.x;
                    currentBoss.spiralCenterY = currentBoss.spiralCenterY || player.y;
                }
                player.slimes.forEach(s => {
                    s.targetEnemyId = s.targetEnemyId || null;
                    s.targetIsBoss = typeof s.targetIsBoss === 'boolean' ? s.targetIsBoss : false;
                    s.lastDamageApplicationTimes = s.lastDamageApplicationTimes || {};
                });
                return true;
            } catch (e) {  localStorage.removeItem('zombieSiegeSaveData'); return false; }
        }

        function calculateBulletDamage() { let baseDmg = player.initialBulletDamage + player.bulletFlatDamageBonus; let finalDmg = baseDmg * (1 + player.bulletDamageMultiplier); return parseFloat(Math.max(finalDmg, player.initialBulletDamage * 0.2).toFixed(1));}
        function calculateSlimeDamage() { return parseFloat(Math.max(player.slimeBaseDamage * (1 + player.slimeDamagePercentMultiplier), player.slimeBaseDamage * 0.2).toFixed(1)); }
        function calculateEnergyWaveDamage() { return parseFloat(Math.max(player.energyWaveBaseDamage * (1 + player.energyWaveDamageMultiplier), player.energyWaveBaseDamage * 0.2).toFixed(1));}

        function updateUI() {
            if (!player) return;
            playerHpDisplay.textContent = Math.max(0, Math.ceil(player.hp)); playerMaxHpDisplay.textContent = player.maxHp; playerHpBar.style.width = `${(Math.max(0, player.hp) / player.maxHp) * 100}%`;
            const xpNeeded = (player.level < XP_PER_LEVEL.length) ? XP_PER_LEVEL[player.level] : XP_PER_LEVEL[XP_PER_LEVEL.length - 1] + (player.level - (XP_PER_LEVEL.length - 1)) * 400;
            playerXpDisplay.textContent = player.xp; xpToLevelUpDisplay.textContent = xpNeeded; playerLevelDisplay.textContent = player.level; playerXpBar.style.width = xpNeeded === Infinity ? '100%' : `${(player.xp / xpNeeded) * 100}%`;
            bulletDamageDisplay.textContent = calculateBulletDamage(); projectileCountDisplay.textContent = player.projectileCount; bulletsPerShotDisplay.textContent = player.bulletsPerShot; bulletPierceCountDisplay.textContent = player.bulletPierceCount;
            hpRegenPer5SecDisplay.textContent = player.hpRegenPer5Sec; xpGainMultiplierDisplay.textContent = `${(player.xpGainMultiplier * 100).toFixed(0)}%`;
            slimeCountDisplay.textContent = player.slimes.length; slimeDamageDisplay.textContent = calculateSlimeDamage(); slimeSpeedMultiplierDisplay.textContent = `${(player.slimeSpeedMultiplier * 100).toFixed(0)}%`;
            hasEnergyWaveDisplay.textContent = player.hasEnergyWave ? '是' : '否'; energyWaveDamageDisplay.textContent = calculateEnergyWaveDamage(); energyWaveCooldownDisplay.textContent = (player.energyWaveCooldown / 1000).toFixed(1);
            waveCountDisplay.textContent = wave; scoreCountDisplay.textContent = score;

            if (currentBoss && currentBoss.hp > 0) {
                middleStatsTitle.textContent = "当前BOSS属性"; middleStatsTitle.style.display = 'block';
                zombieTypeStatContainers.forEach(c => c.style.display = 'none'); zombieStatsNote.style.display = 'none'; bossStatsDisplay.style.display = 'block';
                bossHpDisplay.textContent = Math.ceil(currentBoss.hp); bossMaxHpDisplay.textContent = Math.ceil(currentBoss.maxHp);
                bossSpeedDisplay.textContent = currentBoss.speed.toFixed(2);
            } else {
                middleStatsTitle.textContent = "当前波数僵尸属性"; middleStatsTitle.style.display = 'block';
                zombieTypeStatContainers.forEach(c => c.style.display = 'block'); zombieStatsNote.style.display = 'block'; bossStatsDisplay.style.display = 'none';
                for (const typeKey in ZOMBIE_TYPES) {
                    const baseZombie = ZOMBIE_TYPES[typeKey]; let currentHp, currentDamage, currentSpeed;

                    let waveHpFactor = 0.12; let waveDmgFactor = 1.2; let waveSpeedFactor = 0.003;
                    if (wave > 100) { waveHpFactor = 0.28; waveDmgFactor = 2.4; waveSpeedFactor = 0.0055; }

                    if (wave > 0) {
                        const waveHpBonus = Math.floor(wave / 3) * (baseZombie.hp * waveHpFactor);
                        const waveDmgBonus = Math.floor(wave / 5) * waveDmgFactor;
                        currentHp = baseZombie.hp + waveHpBonus;
                        currentDamage = baseZombie.damage + waveDmgBonus;
                        currentSpeed = baseZombie.speed * (1 + wave * waveSpeedFactor);
                    } else { currentHp = baseZombie.hp; currentDamage = baseZombie.damage; currentSpeed = baseZombie.speed; }

                    if (typeKey === 'normal') { zombieNormalHpDisplay.textContent = currentHp.toFixed(0); zombieNormalDamageDisplay.textContent = currentDamage.toFixed(0); zombieNormalSpeedDisplay.textContent = currentSpeed.toFixed(2); }
                    else if (typeKey === 'fast') { zombieFastHpDisplay.textContent = currentHp.toFixed(0); zombieFastDamageDisplay.textContent = currentDamage.toFixed(0); zombieFastSpeedDisplay.textContent = currentSpeed.toFixed(2); }
                    else if (typeKey === 'tank') { zombieTankHpDisplay.textContent = currentHp.toFixed(0); zombieTankDamageDisplay.textContent = currentDamage.toFixed(0); zombieTankSpeedDisplay.textContent = currentSpeed.toFixed(2); }
                }
            }
        }

        function advanceWave() {
            wave++;
            playSound('waveStart');
            if (autoChangeBackground && wave > 1 && wave % 5 === 0 && nextBackgroundImage) {
                if (backgroundImage !== nextBackgroundImage) {
                    oldBackgroundImage = backgroundImage;
                }
                backgroundImage = nextBackgroundImage;
                backgroundImageProcessed = true;
                crossfadeProgress = 0;
                nextBackgroundImage = null;
                fetchNextBackgroundImage();
            } else if (autoChangeBackground && !isFetchingNextBackground && !nextBackgroundImage) {
                fetchNextBackgroundImage();
            }

            if (currentBoss && currentBoss.hp > 0) return;
            currentBoss = null;
            if (wave > 0 && wave % 10 === 0) { zombies = []; spawnBoss(); }
            else {
                let numZombiesBase = 5;
                let numZombiesPerWave = 2;
                if (wave > 100) {
                    numZombiesPerWave = 4;
                }
                const numZombies = numZombiesBase + wave * numZombiesPerWave;
                for (let i = 0; i < numZombies; i++) spawnZombie();
            }
            updateUI();
        }

        function spawnZombie() {
            let x, y; const edge = Math.floor(Math.random() * 4);
            const spawnMargin = BASE_CANVAS_WIDTH * 0.0375;

            if (edge === 0) { x = Math.random() * BASE_CANVAS_WIDTH; y = -spawnMargin; }
            else if (edge === 1) { x = BASE_CANVAS_WIDTH + spawnMargin; y = Math.random() * BASE_CANVAS_HEIGHT; }
            else if (edge === 2) { x = Math.random() * BASE_CANVAS_WIDTH; y = BASE_CANVAS_HEIGHT + spawnMargin; }
            else { x = -spawnMargin; y = Math.random() * BASE_CANVAS_HEIGHT; }


            let typeKey = 'normal'; const randType = Math.random();
            if (wave > 2 && randType > 0.65) typeKey = 'fast'; if (wave > 4 && randType > 0.85) typeKey = 'tank';
            const type = ZOMBIE_TYPES[typeKey];

            let waveHpFactor = 0.12; let waveDmgFactor = 1.2; let waveSpeedFactor = 0.003;
            if (wave > 100) { waveHpFactor = 0.28; waveDmgFactor = 2.4; waveSpeedFactor = 0.0055; }


            const waveHpBonus = Math.floor(wave / 3) * (type.hp * waveHpFactor);
            const waveDmgBonus = Math.floor(wave / 5) * waveDmgFactor;
            const currentHp = type.hp + waveHpBonus;
            const currentDamage = type.damage + waveDmgBonus;
            const currentSpeed = type.speed * (1 + wave * waveSpeedFactor);

            zombies.push({ id: nextUniqueId++, x, y, hp: currentHp, maxHp: currentHp, speed: currentSpeed, damage: currentDamage, xp: type.xp, color: type.color, size: type.size, type: typeKey });
        }

        function setBossPathTarget(boss) {
            const halfDim = boss.currentPathDimension / 2;
            switch (boss.pathSegment) {
                case 0:
                    boss.pathTargetX = boss.spiralCenterX + halfDim;
                    boss.pathTargetY = boss.spiralCenterY - halfDim;
                    break;
                case 1:
                    boss.pathTargetX = boss.spiralCenterX + halfDim;
                    boss.pathTargetY = boss.spiralCenterY + halfDim;
                    break;
                case 2:
                    boss.pathTargetX = boss.spiralCenterX - halfDim;
                    boss.pathTargetY = boss.spiralCenterY + halfDim;
                    break;
                case 3:
                    boss.pathTargetX = boss.spiralCenterX - halfDim;
                    boss.pathTargetY = boss.spiralCenterY - halfDim;
                    let shrinkMultiplier = 1;
                    if (wave > 100) shrinkMultiplier = 1.35;
                    boss.currentPathDimension -= (BOSS_STATS.pathShrinkAmount * shrinkMultiplier) * (1 + (Math.floor(wave / 10) -1) * 0.1) ;
                    boss.currentPathDimension = Math.max(boss.size * 2, boss.currentPathDimension);
                    break;
            }
            boss.pathTargetX = Math.max(-boss.size * 2, Math.min(BASE_CANVAS_WIDTH + boss.size * 2, boss.pathTargetX));
            boss.pathTargetY = Math.max(-boss.size * 2, Math.min(BASE_CANVAS_HEIGHT + boss.size * 2, boss.pathTargetY));
        }

        function spawnBoss() {
            playSound('bossSpawn', { fadeOutDuration: 8000 });
            const bossLevelMultiplier = Math.max(0, Math.floor(wave / 10) - 1);

            let bossSpeedMultiplierFactor = 0.12;
            let bossHpMultiplier = 1.0;
            if (wave > 100) {
                bossHpMultiplier = 1.75;
            }

            let bossSpeed = BOSS_STATS.speed * (1 + bossLevelMultiplier * bossSpeedMultiplierFactor);
            if (wave > 100 && bossLevelMultiplier > 0) {
                 bossSpeed *= 1.2;
            }

            const initialDim = Math.min(BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT) * BOSS_STATS.initialPathDimensionFactor;

            currentBoss = {
                id: BOSS_STATS.id,
                x: player.x - initialDim / 2,
                y: player.y - initialDim / 2,
                hp: BOSS_STATS.hp * (1 + bossLevelMultiplier * bossHpMultiplier),
                maxHp: BOSS_STATS.hp * (1 + bossLevelMultiplier * bossHpMultiplier),
                color: BOSS_STATS.color,
                size: BOSS_STATS.size,
                damage: BOSS_STATS.damage,
                xp: BOSS_STATS.xp * (1 + bossLevelMultiplier * 0.5),
                speed: bossSpeed,
                pathSegment: 0,
                currentPathDimension: initialDim,
                spiralCenterX: player.x,
                spiralCenterY: player.y,
                pathTargetX: 0, pathTargetY: 0
            };
            setBossPathTarget(currentBoss);
        }

        function drawPlayer() {
            if (!player) return;
            const x = player.x;
            const y = player.y;
            const size = player.size;
            const halfSize = size / 2;
            const cornerRadius = size * 0.25;

            ctx.beginPath();
            ctx.moveTo(x - halfSize + cornerRadius, y - halfSize);
            ctx.lineTo(x + halfSize - cornerRadius, y - halfSize);
            ctx.arcTo(x + halfSize, y - halfSize, x + halfSize, y - halfSize + cornerRadius, cornerRadius);
            ctx.lineTo(x + halfSize, y + halfSize - cornerRadius);
            ctx.arcTo(x + halfSize, y + halfSize, x + halfSize - cornerRadius, y + halfSize, cornerRadius);
            ctx.lineTo(x - halfSize + cornerRadius, y + halfSize);
            ctx.arcTo(x - halfSize, y + halfSize, x - halfSize, y + halfSize - cornerRadius, cornerRadius);
            ctx.lineTo(x - halfSize, y - halfSize + cornerRadius);
            ctx.arcTo(x - halfSize, y - halfSize, x - halfSize + cornerRadius, y - halfSize, cornerRadius);
            ctx.closePath();

            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 2;
            ctx.stroke();

            const nearestTarget = (currentBoss && currentBoss.hp > 0) ? currentBoss : findNearestZombie(player.x, player.y, zombies);
            if (nearestTarget) {
                const angle = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x);
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(angle);

                const barrelLength = size * 0.7;
                const barrelWidth = size * 0.3;
                const barrelBaseOffset = size * 0.1;

                ctx.fillStyle = '#bdc3c7';
                ctx.fillRect(barrelBaseOffset, -barrelWidth / 2, barrelLength, barrelWidth);
                ctx.strokeStyle = '#7f8c8d';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(barrelBaseOffset, -barrelWidth / 2, barrelLength, barrelWidth);

                ctx.restore();
            }
        }

        function drawZombies() {
            zombies.forEach(zombie => {
                const x = zombie.x;
                const y = zombie.y;
                const size = zombie.size;
                const halfSize = size / 2;

                ctx.save();
                ctx.translate(x,y);

                const eyeRadius = size * 0.08;
                const eyeColor = 'rgba(0,0,0,0.7)';
                const pupilColor = 'rgba(255,0,0,0.8)';
                const pupilRadius = eyeRadius * 0.5;

                if (zombie.type === 'normal') {
                    const bodyWidth = size;
                    const bodyHeight = size * 1.1;
                    const cornerRadius = size * 0.3;
                    ctx.fillStyle = zombie.color;
                    ctx.beginPath();
                    if (ctx.roundRect) {
                         ctx.roundRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight, [cornerRadius]);
                    } else {
                        const r = cornerRadius; const w = bodyWidth; const h = bodyHeight; const bx = -bodyWidth/2; const by = -bodyHeight/2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#1e8449';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    ctx.fillStyle = eyeColor;
                    ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, eyeRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(-size*0.15, -size*0.1, pupilRadius*1.2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.15, -size*0.1, pupilRadius*1.2, 0, Math.PI*2); ctx.fill();
                }
                else if (zombie.type === 'fast') {
                    const bodyWidth = size * 0.8;
                    const bodyHeight = size * 1.2;
                    ctx.fillStyle = zombie.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#c29d0b';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();

                    ctx.fillStyle = eyeColor;
                    ctx.beginPath(); ctx.ellipse(-size*0.12, -size*0.15, eyeRadius, eyeRadius*1.5, -Math.PI/6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(size*0.12, -size*0.15, eyeRadius, eyeRadius*1.5, Math.PI/6, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(-size*0.12, -size*0.15, pupilRadius, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(size*0.12, -size*0.15, pupilRadius, 0, Math.PI*2); ctx.fill();
                }
                else if (zombie.type === 'tank') {
                    const bodyWidth = size * 1.3;
                    const bodyHeight = size * 1.1;
                    const cornerRadius = size * 0.2;
                    ctx.fillStyle = zombie.color;
                    ctx.beginPath();
                     if (ctx.roundRect) {
                        ctx.roundRect(-bodyWidth/2, -bodyHeight/2, bodyWidth, bodyHeight, [cornerRadius]);
                    } else {
                        const r = cornerRadius; const w = bodyWidth; const h = bodyHeight; const bx = -bodyWidth/2; const by = -bodyHeight/2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    ctx.strokeStyle = '#962d22';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = 'rgba(50,50,50,0.8)';
                    ctx.beginPath();
                    if (ctx.roundRect) {
                         ctx.roundRect(-size*0.25, -size*0.2, size*0.5, size*0.3, [size*0.05]);
                    } else {
                        const r = size*0.05; const w = size*0.5; const h = size*0.3; const bx = -size*0.25; const by = -size*0.2;
                        ctx.moveTo(bx + r, by);
                        ctx.lineTo(bx + w - r, by); ctx.arcTo(bx + w, by, bx + w, by + r, r);
                        ctx.lineTo(bx + w, by + h - r); ctx.arcTo(bx + w, by + h, bx + w - r, by + h, r);
                        ctx.lineTo(bx + r, by + h); ctx.arcTo(bx, by + h, bx, by + h - r, r);
                        ctx.lineTo(bx, by + r); ctx.arcTo(bx, by, bx + r, by, r);
                        ctx.closePath();
                    }
                    ctx.fill();
                    ctx.fillStyle = pupilColor;
                    ctx.beginPath(); ctx.arc(0, -size*0.05, eyeRadius*1.5, 0, Math.PI*2); ctx.fill();
                }
                ctx.restore();

                if (zombie.hp < zombie.maxHp) {
                    const barWidth = size * 1.2;
                    const barHeight = 4;
                    const barYOffset = halfSize * 1.2 + barHeight;

                    ctx.fillStyle = 'rgba(192, 57, 43, 0.7)';
                    ctx.fillRect(zombie.x - barWidth / 2, zombie.y - barYOffset, barWidth, barHeight);
                    ctx.fillStyle = 'rgba(46, 204, 113, 0.9)';
                    ctx.fillRect(zombie.x - barWidth / 2, zombie.y - barYOffset, barWidth * (zombie.hp / zombie.maxHp), barHeight);
                }
            });
        }

        function drawBoss() {
            if (!currentBoss || currentBoss.hp <= 0) return;
            const x = currentBoss.x;
            const y = currentBoss.y;
            const size = currentBoss.size;
            const bodyColor = currentBoss.color;
            const outlineColor = '#542469';
            const eyeWhiteColor = '#ffffff';
            const eyePupilColor = '#333333';
            const blushColor = 'rgba(255, 150, 150, 0.5)';

            ctx.save();
            ctx.translate(x, y);

            const bodyRadiusX = size * 0.5;
            const bodyRadiusY = size * 0.45;
            ctx.beginPath();
            ctx.ellipse(0, 0, bodyRadiusX, bodyRadiusY, 0, 0, Math.PI * 2);
            ctx.fillStyle = bodyColor;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = size * 0.05;
            ctx.stroke();

            const earRadius = size * 0.1;
            const earOffsetY = -bodyRadiusY * 0.8;
            const earOffsetX = bodyRadiusX * 0.6;

            ctx.beginPath();
            ctx.arc(-earOffsetX, earOffsetY, earRadius, Math.PI, Math.PI * 2);
            ctx.fillStyle = bodyColor;
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(earOffsetX, earOffsetY, earRadius, Math.PI, Math.PI * 2);
            ctx.fillStyle = bodyColor;
            ctx.fill();
            ctx.stroke();

            const eyeRadius = size * 0.12;
            const eyePupilRadius = eyeRadius * 0.5;
            const eyeOffsetX = bodyRadiusX * 0.3;
            const eyeOffsetY = -bodyRadiusY * 0.1;

            ctx.beginPath();
            ctx.arc(-eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = eyeWhiteColor;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = size * 0.02;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-eyeOffsetX + eyeRadius * 0.1, eyeOffsetY + eyeRadius * 0.1, eyePupilRadius, 0, Math.PI * 2);
            ctx.fillStyle = eyePupilColor;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(-eyeOffsetX - eyeRadius * 0.2, eyeOffsetY - eyeRadius * 0.3, eyePupilRadius * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = eyeWhiteColor;
            ctx.fill();

            ctx.beginPath();
            ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
            ctx.fillStyle = eyeWhiteColor;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = size * 0.02;
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(eyeOffsetX + eyeRadius * 0.1, eyeOffsetY + eyeRadius * 0.1, eyePupilRadius, 0, Math.PI * 2);
            ctx.fillStyle = eyePupilColor;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(eyeOffsetX - eyeRadius * 0.2, eyeOffsetY - eyeRadius * 0.3, eyePupilRadius * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = eyeWhiteColor;
            ctx.fill();

            const blushRadius = size * 0.1;
            const blushOffsetY = bodyRadiusY * 0.2;
            const blushOffsetX = bodyRadiusX * 0.4;

            ctx.fillStyle = blushColor;
            ctx.beginPath();
            ctx.ellipse(-blushOffsetX, blushOffsetY, blushRadius, blushRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(blushOffsetX, blushOffsetY, blushRadius, blushRadius * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            if (currentBoss.hp < currentBoss.maxHp) {
                const barWidth = currentBoss.size * 1.2;
                const barHeight = 10;
                const highestPointBossRelativeY = earOffsetY - earRadius;
                const barY = currentBoss.y + highestPointBossRelativeY - barHeight - 10;

                ctx.fillStyle = 'rgba(192, 57, 43, 0.7)';
                ctx.fillRect(currentBoss.x - barWidth / 2, barY, barWidth, barHeight);
                ctx.fillStyle = 'rgba(46, 204, 113, 0.9)';
                ctx.fillRect(currentBoss.x - barWidth / 2, barY, barWidth * (Math.max(0, currentBoss.hp) / currentBoss.maxHp), barHeight);
            }
        }

        function drawBullets() { bullets.forEach(bullet => { ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2); ctx.fill(); }); }

        function drawSlimes() {
            if (!player || !player.slimes) return;
            player.slimes.forEach(slime => {
                const x = slime.x;
                const y = slime.y;
                const radius = slime.size;

                const baseSlimeColor = 'rgba(50, 200, 50, 0.7)';
                const darkerSlimeColor = 'rgba(30, 150, 30, 0.8)';
                const highlightColor = 'rgba(150, 255, 150, 0.6)';

                ctx.beginPath();
                ctx.arc(x + radius * 0.1, y + radius * 0.1, radius, 0, Math.PI * 2);
                ctx.fillStyle = darkerSlimeColor;
                ctx.fill();

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = baseSlimeColor;
                ctx.fill();

                const highlightRadius = radius * 0.5;
                const highlightOffsetX = -radius * 0.25;
                const highlightOffsetY = -radius * 0.3;
                ctx.beginPath();
                ctx.ellipse(x + highlightOffsetX, y + highlightOffsetY, highlightRadius, highlightRadius * 0.7, Math.PI / 4, 0, Math.PI * 2);
                ctx.fillStyle = highlightColor;
                ctx.fill();
            });
        }

        function drawEnergyWaves() {
            energyWaves.forEach(wave => {
                const x = wave.x;
                const y = wave.y;
                const radius = wave.radius;
                const baseThickness = wave.thickness;
                const baseColorString = wave.color;

                let r = 255, g = 100, b = 0, a = 0.6;
                const match = baseColorString.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (match) {
                    r = parseInt(match[1]); g = parseInt(match[2]); b = parseInt(match[3]);
                    a = match[4] ? parseFloat(match[4]) : 1;
                }

                ctx.strokeStyle = `rgba(${Math.min(255,r+80)}, ${Math.min(255,g+80)}, ${Math.min(255,b+50)}, ${Math.min(1, a + 0.3)})`;
                ctx.lineWidth = baseThickness * 0.5;
                ctx.beginPath();
                ctx.arc(x, y, radius - baseThickness * 0.75, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                ctx.lineWidth = baseThickness;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a * 0.4})`;
                ctx.lineWidth = baseThickness * 1.2;
                ctx.beginPath();
                ctx.arc(x, y, radius + baseThickness * 0.75, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function findNearestZombie(fromX, fromY, zombieList) { let nearest = null; let minDist = Infinity; zombieList.forEach(zombie => { const dist = Math.hypot(zombie.x - fromX, zombie.y - fromY); if (dist < minDist) { minDist = dist; nearest = zombie; } }); return nearest; }

        function fireOneSetOfBullets(currentTime) {
            if (!player) return; const nearestTarget = (currentBoss && currentBoss.hp > 0) ? currentBoss : findNearestZombie(player.x, player.y, zombies); if (!nearestTarget) return;
            playSound('shoot');
            const angleToTarget = Math.atan2(nearestTarget.y - player.y, nearestTarget.x - player.x); const bulletDamage = calculateBulletDamage();
            const projectileSpread = player.projectileCount > 1 ? Math.PI / (9 + player.projectileCount * 1.5) : 0; let fanCenterAngle = angleToTarget;
            if (player.projectileCount > 1 && player.projectileCount % 2 === 0) fanCenterAngle -= projectileSpread / 2;
            for (let i = 0; i < player.projectileCount; i++) { const currentAngle = fanCenterAngle - (projectileSpread * (player.projectileCount - 1) / 2) + (i * projectileSpread); const bulletSpawnDist = player.size * 0.5; const offsetX = Math.cos(currentAngle) * bulletSpawnDist; const offsetY = Math.sin(currentAngle) * bulletSpawnDist; bullets.push({ x: player.x + offsetX, y: player.y + offsetY, dx: Math.cos(currentAngle) * 7, dy: Math.sin(currentAngle) * 7, damage: bulletDamage, pierceRemaining: player.bulletPierceCount, hitTargets: new Set() }); }
            timeOfLastBurstBullet = currentTime;
        }

        function updatePlayer(currentTime) {
            if (skillSelectionActive || skillBookOpen || bossRewardModalActive || !player || !gameRunning) return;

            player.x = Math.max(player.size / 2, Math.min(BASE_CANVAS_WIDTH - player.size / 2, player.x));
            player.y = Math.max(player.size / 2, Math.min(BASE_CANVAS_HEIGHT - player.size / 2, player.y));

            if (player.hpRegenPer5Sec > 0 && currentTime - player.lastHpRegenTime > 5000) { player.hp = Math.min(player.hp + player.hpRegenPer5Sec, player.maxHp); player.lastHpRegenTime = currentTime; updateUI(); }
            if (player.currentBulletInBurst === 0 && currentTime - lastShotTime > player.shootCooldown) { fireOneSetOfBullets(currentTime); lastShotTime = currentTime; player.currentBulletInBurst = 1; }
            else if (player.currentBulletInBurst > 0 && player.currentBulletInBurst < player.bulletsPerShot && currentTime - timeOfLastBurstBullet > INTER_BULLET_DELAY) { fireOneSetOfBullets(currentTime); player.currentBulletInBurst++; }
            if (player.currentBulletInBurst >= player.bulletsPerShot) player.currentBulletInBurst = 0;
            if (player.hasEnergyWave && currentTime - player.lastEnergyWaveTime > player.energyWaveCooldown) {
                playSound('energyWaveFire');
                energyWaves.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT) * 0.8, speed: 0.8, thickness: 3, color: 'rgba(255, 100, 0, 0.6)', damage: calculateEnergyWaveDamage(), hitZombies: new Set() }); player.lastEnergyWaveTime = currentTime;
            }
        }

        function updateSlimes(currentTime) {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !player || !player.slimes || !gameRunning) return;
            const slimeDamage = calculateSlimeDamage();

            player.slimes.forEach(slime => {
                let currentTarget = null;

                if (slime.targetEnemyId !== null) {
                    if (slime.targetIsBoss) {
                        if (currentBoss && currentBoss.id === slime.targetEnemyId && currentBoss.hp > 0) {
                            currentTarget = currentBoss;
                        } else {
                            slime.targetEnemyId = null; slime.targetIsBoss = false;
                        }
                    } else {
                        const zombieTarget = zombies.find(z => z.id === slime.targetEnemyId && z.hp > 0);
                        if (zombieTarget) {
                            currentTarget = zombieTarget;
                        } else {
                            slime.targetEnemyId = null;
                        }
                    }
                }

                if (currentTarget === null) {
                    if (currentBoss && currentBoss.hp > 0) {
                        currentTarget = currentBoss;
                        slime.targetEnemyId = currentBoss.id;
                        slime.targetIsBoss = true;
                    } else if (zombies.length > 0) {
                        const nearestZombie = findNearestZombie(slime.x, slime.y, zombies);
                        if (nearestZombie) {
                            currentTarget = nearestZombie;
                            slime.targetEnemyId = nearestZombie.id;
                            slime.targetIsBoss = false;
                        }
                    }
                }

                if (currentTarget) {
                    const angleToTarget = Math.atan2(currentTarget.y - slime.y, currentTarget.x - slime.x);
                    const currentSlimeSpeed = slime.speed * player.slimeSpeedMultiplier;
                    slime.x += Math.cos(angleToTarget) * currentSlimeSpeed;
                    slime.y += Math.sin(angleToTarget) * currentSlimeSpeed;

                    if (Math.hypot(slime.x - currentTarget.x, slime.y - currentTarget.y) < slime.size + currentTarget.size / 2) {
                        if (!slime.lastDamageApplicationTimes[currentTarget.id] || currentTime - slime.lastDamageApplicationTimes[currentTarget.id] > 1000) {
                            currentTarget.hp -= slimeDamage;
                            slime.lastDamageApplicationTimes[currentTarget.id] = currentTime;
                            updateUI();

                            if (currentTarget.hp <= 0) {
                                if (slime.targetIsBoss) {
                                    handleBossDefeat();
                                } else {
                                    playSound('zombieDie');
                                    zombies = zombies.filter(z => z.id !== currentTarget.id);
                                    score += Math.floor(ZOMBIE_TYPES[currentTarget.type].xp * player.xpGainMultiplier * 0.5);
                                }
                                slime.targetEnemyId = null;
                                slime.targetIsBoss = false;
                                if (currentBoss && currentBoss.hp > 0) {
                                    slime.targetEnemyId = currentBoss.id;
                                    slime.targetIsBoss = true;
                                } else if (zombies.length > 0) {
                                     const newNearest = findNearestZombie(slime.x, slime.y, zombies);
                                     if(newNearest) {
                                        slime.targetEnemyId = newNearest.id;
                                        slime.targetIsBoss = false;
                                     }
                                }
                            }
                        }
                    }
                }
            });
        }


        function updateEnergyWaves() {
            if (!gameRunning) return;
            for (let i = energyWaves.length - 1; i >= 0; i--) {
                const wave = energyWaves[i]; wave.radius += wave.speed;
                if (wave.radius > wave.maxRadius) { energyWaves.splice(i, 1); continue; }
                for (let j = zombies.length - 1; j >= 0; j--) {
                    const zombie = zombies[j]; if (!wave.hitZombies.has(zombie.id)) {
                        const dist = Math.hypot(zombie.x - wave.x, zombie.y - wave.y);
                        if (dist >= wave.radius - zombie.size / 2 - wave.thickness && dist <= wave.radius + zombie.size / 2 + wave.thickness) {
                            zombie.hp -= wave.damage; wave.hitZombies.add(zombie.id);
                            if (zombie.hp <= 0) { playSound('zombieDie'); zombies.splice(j, 1); score += Math.floor(ZOMBIE_TYPES[zombie.type].xp * player.xpGainMultiplier * 0.75); updateUI(); }
                        }
                    }
                }
                if (currentBoss && currentBoss.hp > 0 && !wave.hitZombies.has(currentBoss.id)) {
                    const dist = Math.hypot(currentBoss.x - wave.x, currentBoss.y - wave.y);
                    if (dist >= wave.radius - currentBoss.size / 2 - wave.thickness && dist <= wave.radius + currentBoss.size / 2 + wave.thickness) {
                        currentBoss.hp -= wave.damage; wave.hitZombies.add(currentBoss.id); updateUI();
                        if (currentBoss.hp <= 0) handleBossDefeat();
                    }
                }
            }
        }

        function updateZombies() {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !player || !gameRunning) return;
            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                const angle = Math.atan2(player.y - zombie.y, player.x - zombie.x);
                zombie.x += Math.cos(angle) * zombie.speed;
                zombie.y += Math.sin(angle) * zombie.speed;

                if (Math.hypot(player.x - zombie.x, player.y - zombie.y) < (player.size / 2 + zombie.size / 2)) {
                    playSound('playerHurt');
                    player.hp -= zombie.damage;
                    zombies.splice(i, 1);
                    if (player.hp <= 0) gameOver();
                    updateUI();
                }
            }
        }

        function updateBoss() {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !currentBoss || !player || !gameRunning || currentBoss.hp <= 0) return;

            currentBoss.spiralCenterX = player.x;
            currentBoss.spiralCenterY = player.y;

            const tempSegment = currentBoss.pathSegment;
            const tempDimension = currentBoss.currentPathDimension;
            setBossPathTarget(currentBoss);
            if (tempSegment === 3 && currentBoss.pathSegment === 0 && currentBoss.currentPathDimension < tempDimension) {
                 setBossPathTarget(currentBoss);
            }

            let dx = currentBoss.pathTargetX - currentBoss.x;
            let dy = currentBoss.pathTargetY - currentBoss.y;
            const distToTarget = Math.hypot(dx, dy);

            if (distToTarget < currentBoss.speed + 1.5) {
                currentBoss.x = currentBoss.pathTargetX;
                currentBoss.y = currentBoss.pathTargetY;
                currentBoss.pathSegment = (currentBoss.pathSegment + 1) % 4;
                setBossPathTarget(currentBoss);
            } else {
                currentBoss.x += (dx / distToTarget) * currentBoss.speed;
                currentBoss.y += (dy / distToTarget) * currentBoss.speed;
            }

            if (Math.hypot(player.x - currentBoss.x, player.y - currentBoss.y) < (player.size / 2 + currentBoss.size / 2)) {
                 playSound('playerHurt');
                 player.hp = 0;
                 gameOver();
                 return;
            }
             if (currentBoss.currentPathDimension <= currentBoss.size * 2) {
                 const angleToPlayer = Math.atan2(player.y - currentBoss.y, player.x - currentBoss.x);
                 currentBoss.x += Math.cos(angleToPlayer) * currentBoss.speed;
                 currentBoss.y += Math.sin(angleToPlayer) * currentBoss.speed;
            }
        }


        function updateBullets() {
            if (skillBookOpen || skillSelectionActive || bossRewardModalActive || !gameRunning) return;
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; bullet.x += bullet.dx; bullet.y += bullet.dy;
                if (!bullet.hitTargets) bullet.hitTargets = new Set();
                if (bullet.x < -50 || bullet.x > BASE_CANVAS_WIDTH + 50 || bullet.y < -50 || bullet.y > BASE_CANVAS_HEIGHT + 50) {
                    bullets.splice(i, 1); continue;
                }
                let bulletRemovedThisIteration = false;
                for (let j = zombies.length - 1; j >= 0; j--) {
                    if (bulletRemovedThisIteration) break; const zombie = zombies[j]; if (bullet.hitTargets.has(zombie.id)) continue;
                    if (Math.hypot(bullet.x - zombie.x, bullet.y - zombie.y) < (zombie.size / 2 + 3)) {
                        zombie.hp -= bullet.damage; bullet.hitTargets.add(zombie.id);
                        if (zombie.hp <= 0) { playSound('zombieDie'); zombies.splice(j, 1); const gainedXp = Math.floor(ZOMBIE_TYPES[zombie.type].xp * player.xpGainMultiplier); player.xp += gainedXp; score += gainedXp; checkLevelUp(); updateUI(); }
                        if (bullet.pierceRemaining > 0) bullet.pierceRemaining--; else { bullets.splice(i, 1); bulletRemovedThisIteration = true; }
                    }
                }
                if (bulletRemovedThisIteration) continue;
                if (currentBoss && currentBoss.hp > 0 && !bullet.hitTargets.has(currentBoss.id)) {
                    if (Math.hypot(bullet.x - currentBoss.x, bullet.y - currentBoss.y) < (currentBoss.size / 2 + 3)) {
                        currentBoss.hp -= bullet.damage; bullet.hitTargets.add(currentBoss.id); updateUI();
                        if (currentBoss.hp <= 0) handleBossDefeat();
                        if (bullet.pierceRemaining > 0) bullet.pierceRemaining--; else bullets.splice(i, 1);
                    }
                }
            }
        }

        function handleBossDefeat() {
            if (!currentBoss) return;
            playSound('bossDie');
            if (activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
                activeBossSpawnSound = null;
            }
            const bossXp = Math.floor(currentBoss.xp * player.xpGainMultiplier);
            score += bossXp; player.xp += bossXp;
            checkLevelUp();

            currentBoss = null;

            const grantedSkills = [];
            let availableChoices = ALL_SKILLS.filter(skill => { const currentStacks = player.learnedSkills[skill.id] || 0; if (skill.maxStacks !== undefined && currentStacks >= skill.maxStacks) return false; if (skill.prerequisite && !(player.learnedSkills[skill.prerequisite] > 0)) return false; return true; });
            for (let i = 0; i < 3 && availableChoices.length > 0; i++) {
                const randomIndex = Math.floor(Math.random() * availableChoices.length);
                const chosenSkill = availableChoices.splice(randomIndex, 1)[0];
                chosenSkill.apply(player);
                player.learnedSkills[chosenSkill.id] = (player.learnedSkills[chosenSkill.id] || 0) + 1;
                grantedSkills.push(chosenSkill);
            }
            if (grantedSkills.length > 0) playSound('skillAcquired');
            presentBossRewardModal(grantedSkills);
            updateUI();
        }

        function presentBossRewardModal(skills) {
            bossRewardModalActive = true; bossRewardSkillList.innerHTML = '';
            if (skills.length === 0) { bossRewardSkillList.innerHTML = '<p>没有可授予的新技能。</p>'; }
            else { const ul = document.createElement('ul'); skills.forEach(skill => { const li = document.createElement('li'); li.textContent = skill.name; ul.appendChild(li); }); bossRewardSkillList.appendChild(ul); }
            bossRewardModal.style.display = 'block'; let timeLeft = 6; bossRewardTimerDisplay.textContent = `关闭倒计时: ${timeLeft}s`;
            if (bossRewardCountdownIntervalId) clearInterval(bossRewardCountdownIntervalId);
            bossRewardCountdownIntervalId = setInterval(() => { timeLeft--; bossRewardTimerDisplay.textContent = `关闭倒计时: ${timeLeft}s`; if (timeLeft <= 0) closeBossRewardModal(); }, 1000);
            if (bossRewardTimeoutId) clearTimeout(bossRewardTimeoutId); bossRewardTimeoutId = setTimeout(closeBossRewardModal, 6000);
        }

        function closeBossRewardModal() {
            playSound('buttonClick');
            bossRewardModalActive = false; bossRewardModal.style.display = 'none';
            if (bossRewardCountdownIntervalId) clearInterval(bossRewardCountdownIntervalId); if (bossRewardTimeoutId) clearTimeout(bossRewardTimeoutId);
            if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop);
        }

        function checkLevelUp() {
            if (!player || !gameRunning) return;
            const currentLevelXpNeeded = (player.level < XP_PER_LEVEL.length) ? XP_PER_LEVEL[player.level] : XP_PER_LEVEL[XP_PER_LEVEL.length - 1] + (player.level - (XP_PER_LEVEL.length - 1)) * 400;
            if (player.xp >= currentLevelXpNeeded) {
                playSound('levelUp');
                player.level++; player.xp -= currentLevelXpNeeded; presentSkillSelection();
            }
        }

        function presentSkillSelection() {
            if (skillSelectionActive || bossRewardModalActive || !player || !gameRunning) return;
            skillSelectionActive = true; skillOptionsContainer.innerHTML = '';
            const availableChoices = ALL_SKILLS.filter(skill => { const currentStacks = player.learnedSkills[skill.id] || 0; if (skill.maxStacks !== undefined && currentStacks >= skill.maxStacks) return false; if (skill.prerequisite && !(player.learnedSkills[skill.prerequisite] > 0)) return false; return true; });
            availableChoices.sort((a, b) => { const categoryAIndex = SKILL_CATEGORY_ORDER.indexOf(a.category); const categoryBIndex = SKILL_CATEGORY_ORDER.indexOf(b.category); if (categoryAIndex !== categoryBIndex) return categoryAIndex - categoryBIndex; return a.name.localeCompare(b.name, 'zh-CN'); });
            const chosenSkills = []; let tempAvailable = [...availableChoices];
            while(chosenSkills.length < 3 && tempAvailable.length > 0) { const randomIndex = Math.floor(Math.random() * tempAvailable.length); chosenSkills.push(tempAvailable.splice(randomIndex, 1)[0]); }
            if (chosenSkills.length === 0) { skillSelectionActive = false; if (gameRunning && animationFrameId === null) { animationFrameId = requestAnimationFrame(gameLoop); } return; }
            chosenSkills.forEach(skill => { const button = document.createElement('button'); button.className = 'skill-option-btn'; button.textContent = `${skill.name} - ${skill.description}`; button.onclick = () => selectSkill(skill); skillOptionsContainer.appendChild(button); });
            skillModal.style.display = 'block'; let timeLeft = 6; skillTimerDisplay.textContent = `剩余时间: ${timeLeft}s`;
            if (skillSelectionCountdownIntervalId) clearInterval(skillSelectionCountdownIntervalId);
            skillSelectionCountdownIntervalId = setInterval(() => { timeLeft--; skillTimerDisplay.textContent = `剩余时间: ${timeLeft}s`; if (timeLeft <= 0) { clearInterval(skillSelectionCountdownIntervalId); const randomSkillIndex = Math.floor(Math.random() * chosenSkills.length); selectSkill(chosenSkills[randomSkillIndex]); } }, 1000);
        }

        function selectSkill(skill) {
            if (!skillSelectionActive || !player) return;
            playSound('skillSelect');
            skill.apply(player); player.learnedSkills[skill.id] = (player.learnedSkills[skill.id] || 0) + 1;
            skillModal.style.display = 'none'; skillSelectionActive = false;
            if (skillSelectionCountdownIntervalId) clearInterval(skillSelectionCountdownIntervalId);
            updateUI(); if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop);
        }

        function toggleSkillBook() {
            playSound('buttonClick');
            skillBookOpen = !skillBookOpen;
            if (skillBookOpen) { renderSkillBook(); skillBookModal.style.display = 'block'; }
            else { skillBookModal.style.display = 'none'; if (gameRunning && animationFrameId === null) animationFrameId = requestAnimationFrame(gameLoop); }
        }

        function renderSkillBook() {
            if (!player) return; skillBookContent.innerHTML = '';
            const sortedSkills = [...ALL_SKILLS].sort((a, b) => { const categoryAIndex = SKILL_CATEGORY_ORDER.indexOf(a.category); const categoryBIndex = SKILL_CATEGORY_ORDER.indexOf(b.category); if (categoryAIndex !== categoryBIndex) return categoryAIndex - categoryBIndex; return a.name.localeCompare(b.name, 'zh-CN'); });
            sortedSkills.forEach(skill => { const level = player.learnedSkills[skill.id] || 0; const entryDiv = document.createElement('div'); entryDiv.className = 'skill-entry' + (level > 0 ? ' learned' : ''); let skillTitle = `<h4>${skill.name}`; if (level > 0) skillTitle += ` <span class="skill-level">(等级 ${level})</span>`; if (skill.maxStacks !== undefined) skillTitle += ` (最大 ${skill.maxStacks}级)`; skillTitle += `</h4>`; entryDiv.innerHTML = `${skillTitle}<p>${skill.description}</p>`; skillBookContent.appendChild(entryDiv); });
        }

        function gameOver() {
            playSound('gameOver');
            if (activeBossSpawnSound) {
                fadeOutAndStop(activeBossSpawnSound, 500);
                activeBossSpawnSound = null;
            }
            gameRunning = false; finalWaveDisplay.textContent = wave; finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'block';
        }

        function drawSingleBackground(bgImage, alpha = 1) {
            if (bgImage && bgImage.complete && bgImage.naturalHeight !== 0) {
                ctx.globalAlpha = alpha;
                const canvasAspect = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT; 
                const imgAspect = bgImage.naturalWidth / bgImage.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                if (canvasAspect > imgAspect) { 
                    drawWidth = BASE_CANVAS_WIDTH;
                    drawHeight = BASE_CANVAS_WIDTH / imgAspect;
                    drawX = 0;
                    drawY = (BASE_CANVAS_HEIGHT - drawHeight) / 2;
                } else { 
                    drawHeight = BASE_CANVAS_HEIGHT;
                    drawWidth = BASE_CANVAS_HEIGHT * imgAspect;
                    drawY = 0;
                    drawX = (BASE_CANVAS_WIDTH - drawWidth) / 2;
                }
                ctx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
                ctx.globalAlpha = 1;
            } else if (alpha === 1) { 
                ctx.fillStyle = '#333745';
                ctx.fillRect(0, 0, BASE_CANVAS_WIDTH, BASE_CANVAS_HEIGHT);
            }
        }

        function drawGameBackground() {
            if (crossfadeProgress < 1 && oldBackgroundImage && backgroundImage && oldBackgroundImage !== backgroundImage) {
                drawSingleBackground(oldBackgroundImage, 1 - crossfadeProgress);
                drawSingleBackground(backgroundImage, crossfadeProgress);
            } else {
                drawSingleBackground(backgroundImage);
                if (oldBackgroundImage && crossfadeProgress >= 1) {
                    oldBackgroundImage = null;
                }
            }
        }


        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastLoopTimestamp;
            lastLoopTimestamp = timestamp;

            if (!gameRunning && !skillBookOpen && !bossRewardModalActive) { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } return; }

            if (crossfadeProgress < 1 && oldBackgroundImage) {
                crossfadeProgress += (deltaTime / crossfadeDuration);
                crossfadeProgress = Math.min(1, crossfadeProgress);
                 if (crossfadeProgress >= 1) {
                    oldBackgroundImage = null;
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const scaleX = canvas.width / BASE_CANVAS_WIDTH;
            const scaleY = canvas.height / BASE_CANVAS_HEIGHT;
            const scale = Math.min(scaleX, scaleY);

            const renderWidth = BASE_CANVAS_WIDTH * scale;
            const renderHeight = BASE_CANVAS_HEIGHT * scale;

            const offsetX = (canvas.width - renderWidth) / 2;
            const offsetY = (canvas.height - renderHeight) / 2;

            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            drawGameBackground();

            if (gameRunning && !skillSelectionActive && !skillBookOpen && !bossRewardModalActive) {
                updatePlayer(timestamp);
                updateSlimes(timestamp);
                updateEnergyWaves();
                if (currentBoss && currentBoss.hp > 0) updateBoss(); else if (!currentBoss) updateZombies();
                updateBullets();
            }

            drawPlayer();
            drawSlimes();
            drawEnergyWaves();
            if (currentBoss && currentBoss.hp > 0) drawBoss(); else if (!currentBoss) drawZombies();
            drawBullets();

            ctx.restore();

            if (gameRunning && !skillSelectionActive && !skillBookOpen && !bossRewardModalActive) {
                if ((!currentBoss || currentBoss.hp <= 0) && zombies.length === 0) {
                    advanceWave();
                }
            }

            if (gameRunning || skillBookOpen || bossRewardModalActive) animationFrameId = requestAnimationFrame(gameLoop);
            else { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }}
        }

        function initCollapsiblePanels() {
            const panelHeaders = document.querySelectorAll('.collapsible-panel-header');
            const panelStates = JSON.parse(localStorage.getItem('zombieSiegePanelStates')) || {};

            panelHeaders.forEach(header => {
                const panelId = header.dataset.panelId;
                const content = header.nextElementSibling;
                const btn = header.querySelector('.collapsible-panel-toggle-btn');

                if (!content || !btn) {
                    return;
                }

                let isInitiallyExpanded = true;
                if (panelId && typeof panelStates[panelId] === 'boolean') {
                    isInitiallyExpanded = panelStates[panelId];
                }

                if (!isInitiallyExpanded) {
                    content.classList.add('collapsed');
                    btn.textContent = '+';
                    btn.setAttribute('aria-expanded', 'false');
                    header.classList.add('collapsed-state');
                } else {
                    content.classList.remove('collapsed');
                    btn.textContent = '-';
                    btn.setAttribute('aria-expanded', 'true');
                    header.classList.remove('collapsed-state');
                }

                header.addEventListener('click', function(event) {
                    if (event.target === btn) return;
                    btn.click();
                });

                btn.addEventListener('click', function(event) {
                    event.stopPropagation();

                    if (typeof playSound === 'function' && soundEffectPaths.buttonClick) {
                         playSound('buttonClick');
                    }

                    content.classList.toggle('collapsed');
                    const isExpanded = !content.classList.contains('collapsed');
                    this.textContent = isExpanded ? '-' : '+';
                    this.setAttribute('aria-expanded', isExpanded);

                    if (isExpanded) {
                        header.classList.remove('collapsed-state');
                    } else {
                        header.classList.add('collapsed-state');
                    }

                    if (panelId) {
                        panelStates[panelId] = isExpanded;
                        localStorage.setItem('zombieSiegePanelStates', JSON.stringify(panelStates));
                    }
                });
            });
        }

        function resizeCanvas() {
            const containerWidth = gameCanvasContainer.offsetWidth;
            // The height is determined by padding-top to maintain aspect ratio for the container
            // So, canvas.height should match container's computed height
            const containerHeight = gameCanvasContainer.offsetHeight;


            canvas.width = containerWidth;
            canvas.height = containerHeight;
        }


        window.onload = () => {
            toggleSoundBtn = document.createElement('button');
            toggleSoundBtn.onclick = () => { playSound('buttonClick'); toggleSound(); };
            const gameButtonsDiv = document.querySelector('.stats-right .game-buttons');
            if (gameButtonsDiv) {
                const bgBtn = document.getElementById('toggleBgBtn');
                if (bgBtn && bgBtn.nextSibling) {
                    gameButtonsDiv.insertBefore(toggleSoundBtn, bgBtn.nextSibling);
                } else if (bgBtn) {
                    gameButtonsDiv.appendChild(toggleSoundBtn);
                }
                 else {
                    gameButtonsDiv.appendChild(toggleSoundBtn);
                }
            }

            const savedAutoBg = localStorage.getItem('zombieSiegeAutoBg');
            if (savedAutoBg !== null) {
                autoChangeBackground = JSON.parse(savedAutoBg);
            }
            const bgBtnElement = document.getElementById('toggleBgBtn');
            if(bgBtnElement) {
                 bgBtnElement.textContent = `更换背景: ${autoChangeBackground ? '开' : '关'}`;
            }

            initCollapsiblePanels();

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); 
            initGame();
        };
    </script>
</body>
</html>